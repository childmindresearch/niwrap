# This file was auto generated by styx
# Do not edit this file directly

import dataclasses
import pathlib
import typing

from styxdefs import *


MRCALC_METADATA = Metadata(
    id="2e423f3fe9161ef8a5360bd0c1aa599bcabcd1a8",
    name="mrcalc",
    container_image_type="docker",
    container_image_tag="mrtrix3/mrtrix3:3.0.4",
)


@dataclasses.dataclass
class MrcalcAbs:
    """
    |%1| : return absolute value (magnitude) of real or complex number
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-abs")
        return cargs


@dataclasses.dataclass
class MrcalcNeg:
    """
    -%1 : negative value
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-neg")
        return cargs


@dataclasses.dataclass
class MrcalcAdd:
    """
    (%1 + %2) : add values
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-add")
        return cargs


@dataclasses.dataclass
class MrcalcSubtract:
    """
    (%1 - %2) : subtract nth operand from (n-1)th
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-subtract")
        return cargs


@dataclasses.dataclass
class MrcalcMultiply:
    """
    (%1 * %2) : multiply values
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-multiply")
        return cargs


@dataclasses.dataclass
class MrcalcDivide:
    """
    (%1 / %2) : divide (n-1)th operand by nth
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-divide")
        return cargs


@dataclasses.dataclass
class MrcalcMin:
    """
    min (%1, %2) : smallest of last two operands
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-min")
        return cargs


@dataclasses.dataclass
class MrcalcMax:
    """
    max (%1, %2) : greatest of last two operands
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-max")
        return cargs


@dataclasses.dataclass
class MrcalcLt:
    """
    (%1 < %2) : less-than operator (true=1, false=0)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-lt")
        return cargs


@dataclasses.dataclass
class MrcalcGt:
    """
    (%1 > %2) : greater-than operator (true=1, false=0)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-gt")
        return cargs


@dataclasses.dataclass
class MrcalcLe:
    """
    (%1 <= %2) : less-than-or-equal-to operator (true=1, false=0)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-le")
        return cargs


@dataclasses.dataclass
class MrcalcGe:
    """
    (%1 >= %2) : greater-than-or-equal-to operator (true=1, false=0)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-ge")
        return cargs


@dataclasses.dataclass
class MrcalcEq:
    """
    (%1 == %2) : equal-to operator (true=1, false=0)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-eq")
        return cargs


@dataclasses.dataclass
class MrcalcNeq:
    """
    (%1 != %2) : not-equal-to operator (true=1, false=0)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-neq")
        return cargs


@dataclasses.dataclass
class MrcalcIf:
    """
    (%1 ? %2 : %3) : if first operand is true (non-zero), return second operand, otherwise return third operand
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-if")
        return cargs


@dataclasses.dataclass
class MrcalcReplace:
    """
    (%1, %2 -> %3) : Wherever first operand is equal to the second operand, replace with third operand
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-replace")
        return cargs


@dataclasses.dataclass
class MrcalcSqrt:
    """
    sqrt (%1) : square root
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-sqrt")
        return cargs


@dataclasses.dataclass
class MrcalcPow:
    """
    %1^%2 : raise (n-1)th operand to nth power
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-pow")
        return cargs


@dataclasses.dataclass
class MrcalcRound:
    """
    round (%1) : round to nearest integer
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-round")
        return cargs


@dataclasses.dataclass
class MrcalcCeil:
    """
    ceil (%1) : round up to nearest integer
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-ceil")
        return cargs


@dataclasses.dataclass
class MrcalcFloor:
    """
    floor (%1) : round down to nearest integer
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-floor")
        return cargs


@dataclasses.dataclass
class MrcalcNot:
    """
    !%1 : NOT operator: true (1) if operand is false (i.e. zero)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-not")
        return cargs


@dataclasses.dataclass
class MrcalcAnd:
    """
    (%1 && %2) : AND operator: true (1) if both operands are true (i.e. non-zero)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-and")
        return cargs


@dataclasses.dataclass
class MrcalcOr:
    """
    (%1 || %2) : OR operator: true (1) if either operand is true (i.e. non-zero)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-or")
        return cargs


@dataclasses.dataclass
class MrcalcXor:
    """
    (%1 ^^ %2) : XOR operator: true (1) if only one of the operands is true (i.e. non-zero)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-xor")
        return cargs


@dataclasses.dataclass
class MrcalcIsnan:
    """
    isnan (%1) : true (1) if operand is not-a-number (NaN)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-isnan")
        return cargs


@dataclasses.dataclass
class MrcalcIsinf:
    """
    isinf (%1) : true (1) if operand is infinite (Inf)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-isinf")
        return cargs


@dataclasses.dataclass
class MrcalcFinite:
    """
    finite (%1) : true (1) if operand is finite (i.e. not NaN or Inf)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-finite")
        return cargs


@dataclasses.dataclass
class MrcalcComplex:
    """
    (%1 + %2 i) : create complex number using the last two operands as real,imaginary components
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-complex")
        return cargs


@dataclasses.dataclass
class MrcalcPolar:
    """
    (%1 /_ %2) : create complex number using the last two operands as magnitude,phase components (phase in radians)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-polar")
        return cargs


@dataclasses.dataclass
class MrcalcReal:
    """
    real (%1) : real part of complex number
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-real")
        return cargs


@dataclasses.dataclass
class MrcalcImag:
    """
    imag (%1) : imaginary part of complex number
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-imag")
        return cargs


@dataclasses.dataclass
class MrcalcPhase:
    """
    phase (%1) : phase of complex number (use -abs for magnitude)
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-phase")
        return cargs


@dataclasses.dataclass
class MrcalcConj:
    """
    conj (%1) : complex conjugate
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-conj")
        return cargs


@dataclasses.dataclass
class MrcalcProj:
    """
    proj (%1) : projection onto the Riemann sphere
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-proj")
        return cargs


@dataclasses.dataclass
class MrcalcExp:
    """
    exp (%1) : exponential function
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-exp")
        return cargs


@dataclasses.dataclass
class MrcalcLog:
    """
    log (%1) : natural logarithm
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-log")
        return cargs


@dataclasses.dataclass
class MrcalcLog10:
    """
    log10 (%1) : common logarithm
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-log10")
        return cargs


@dataclasses.dataclass
class MrcalcCos:
    """
    cos (%1) : cosine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-cos")
        return cargs


@dataclasses.dataclass
class MrcalcSin:
    """
    sin (%1) : sine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-sin")
        return cargs


@dataclasses.dataclass
class MrcalcTan:
    """
    tan (%1) : tangent
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-tan")
        return cargs


@dataclasses.dataclass
class MrcalcAcos:
    """
    acos (%1) : inverse cosine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-acos")
        return cargs


@dataclasses.dataclass
class MrcalcAsin:
    """
    asin (%1) : inverse sine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-asin")
        return cargs


@dataclasses.dataclass
class MrcalcAtan:
    """
    atan (%1) : inverse tangent
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-atan")
        return cargs


@dataclasses.dataclass
class MrcalcCosh:
    """
    cosh (%1) : hyperbolic cosine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-cosh")
        return cargs


@dataclasses.dataclass
class MrcalcSinh:
    """
    sinh (%1) : hyperbolic sine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-sinh")
        return cargs


@dataclasses.dataclass
class MrcalcTanh:
    """
    tanh (%1) : hyperbolic tangent
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-tanh")
        return cargs


@dataclasses.dataclass
class MrcalcAcosh:
    """
    acosh (%1) : inverse hyperbolic cosine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-acosh")
        return cargs


@dataclasses.dataclass
class MrcalcAsinh:
    """
    asinh (%1) : inverse hyperbolic sine
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-asinh")
        return cargs


@dataclasses.dataclass
class MrcalcAtanh:
    """
    atanh (%1) : inverse hyperbolic tangent
    """
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-atanh")
        return cargs


@dataclasses.dataclass
class MrcalcConfig:
    """
    temporarily set the value of an MRtrix config file entry.
    """
    key: str
    """temporarily set the value of an MRtrix config file entry."""
    value: str
    """temporarily set the value of an MRtrix config file entry."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("-config")
        cargs.extend(["", self.key])
        cargs.extend(["", self.value])
        return cargs


class MrcalcOutputs(typing.NamedTuple):
    """
    Output object returned when calling `mrcalc(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mrcalc(
    operand: list[str],
    abs_: list[MrcalcAbs] = None,
    neg: list[MrcalcNeg] = None,
    add: list[MrcalcAdd] = None,
    subtract: list[MrcalcSubtract] = None,
    multiply: list[MrcalcMultiply] = None,
    divide: list[MrcalcDivide] = None,
    min_: list[MrcalcMin] = None,
    max_: list[MrcalcMax] = None,
    lt: list[MrcalcLt] = None,
    gt: list[MrcalcGt] = None,
    le: list[MrcalcLe] = None,
    ge: list[MrcalcGe] = None,
    eq: list[MrcalcEq] = None,
    neq: list[MrcalcNeq] = None,
    if_: list[MrcalcIf] = None,
    replace: list[MrcalcReplace] = None,
    sqrt: list[MrcalcSqrt] = None,
    pow_: list[MrcalcPow] = None,
    round_: list[MrcalcRound] = None,
    ceil: list[MrcalcCeil] = None,
    floor: list[MrcalcFloor] = None,
    not_: list[MrcalcNot] = None,
    and_: list[MrcalcAnd] = None,
    or_: list[MrcalcOr] = None,
    xor: list[MrcalcXor] = None,
    isnan: list[MrcalcIsnan] = None,
    isinf: list[MrcalcIsinf] = None,
    finite: list[MrcalcFinite] = None,
    complex_: list[MrcalcComplex] = None,
    polar: list[MrcalcPolar] = None,
    real: list[MrcalcReal] = None,
    imag: list[MrcalcImag] = None,
    phase: list[MrcalcPhase] = None,
    conj: list[MrcalcConj] = None,
    proj: list[MrcalcProj] = None,
    exp: list[MrcalcExp] = None,
    log: list[MrcalcLog] = None,
    log10: list[MrcalcLog10] = None,
    cos: list[MrcalcCos] = None,
    sin: list[MrcalcSin] = None,
    tan: list[MrcalcTan] = None,
    acos: list[MrcalcAcos] = None,
    asin: list[MrcalcAsin] = None,
    atan: list[MrcalcAtan] = None,
    cosh: list[MrcalcCosh] = None,
    sinh: list[MrcalcSinh] = None,
    tanh: list[MrcalcTanh] = None,
    acosh: list[MrcalcAcosh] = None,
    asinh: list[MrcalcAsinh] = None,
    atanh: list[MrcalcAtanh] = None,
    datatype: typing.Literal["spec"] | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[MrcalcConfig] = None,
    help_: bool = False,
    version: bool = False,
    runner: Runner = None,
) -> MrcalcOutputs:
    """
    mrcalc by J-Donald Tournier (jdtournier@gmail.com).
    
    Apply generic voxel-wise mathematical operations to images.
    
    This command will only compute per-voxel operations. Use 'mrmath' to compute
    summary statistics across images or along image axes.
    
    This command uses a stack-based syntax, with operators (specified using
    options) operating on the top-most entries (i.e. images or values) in the
    stack. Operands (values or images) are pushed onto the stack in the order
    they appear (as arguments) on the command-line, and operators (specified as
    options) operate on and consume the top-most entries in the stack, and push
    their output as a new entry on the stack.
    
    As an additional feature, this command will allow images with different
    dimensions to be processed, provided they satisfy the following conditions:
    for each axis, the dimensions match if they are the same size, or one of
    them has size one. In the latter case, the entire image will be replicated
    along that axis. This allows for example a 4D image of size [ X Y Z N ] to
    be added to a 3D image of size [ X Y Z ], as if it consisted of N copies of
    the 3D image along the 4th axis (the missing dimension is assumed to have
    size 1). Another example would a single-voxel 4D image of size [ 1 1 1 N ],
    multiplied by a 3D image of size [ X Y Z ], which would allow the creation
    of a 4D image where each volume consists of the 3D image scaled by the
    corresponding value for that volume in the single-voxel image.
    
    References:
    
    .
    
    More information:
    https://mrtrix.readthedocs.io/en/latest/reference/commands/mrcalc.html
    
    Args:
        operand: an input image, intensity value, or the special keywords 'rand'
            (random number between 0 and 1) or 'randn' (random number from unit
            std.dev. normal distribution) or the mathematical constants 'e' and
            'pi'.
        abs_: |%1| : return absolute value (magnitude) of real or complex number
        neg: -%1 : negative value
        add: (%1 + %2) : add values
        subtract: (%1 - %2) : subtract nth operand from (n-1)th
        multiply: (%1 * %2) : multiply values
        divide: (%1 / %2) : divide (n-1)th operand by nth
        min_: min (%1, %2) : smallest of last two operands
        max_: max (%1, %2) : greatest of last two operands
        lt: (%1 < %2) : less-than operator (true=1, false=0)
        gt: (%1 > %2) : greater-than operator (true=1, false=0)
        le: (%1 <= %2) : less-than-or-equal-to operator (true=1, false=0)
        ge: (%1 >= %2) : greater-than-or-equal-to operator (true=1, false=0)
        eq: (%1 == %2) : equal-to operator (true=1, false=0)
        neq: (%1 != %2) : not-equal-to operator (true=1, false=0)
        if_: (%1 ? %2 : %3) : if first operand is true (non-zero), return second
            operand, otherwise return third operand
        replace: (%1, %2 -> %3) : Wherever first operand is equal to the second
            operand, replace with third operand
        sqrt: sqrt (%1) : square root
        pow_: %1^%2 : raise (n-1)th operand to nth power
        round_: round (%1) : round to nearest integer
        ceil: ceil (%1) : round up to nearest integer
        floor: floor (%1) : round down to nearest integer
        not_: !%1 : NOT operator: true (1) if operand is false (i.e. zero)
        and_: (%1 && %2) : AND operator: true (1) if both operands are true
            (i.e. non-zero)
        or_: (%1 || %2) : OR operator: true (1) if either operand is true (i.e.
            non-zero)
        xor: (%1 ^^ %2) : XOR operator: true (1) if only one of the operands is
            true (i.e. non-zero)
        isnan: isnan (%1) : true (1) if operand is not-a-number (NaN)
        isinf: isinf (%1) : true (1) if operand is infinite (Inf)
        finite: finite (%1) : true (1) if operand is finite (i.e. not NaN or
            Inf)
        complex_: (%1 + %2 i) : create complex number using the last two
            operands as real,imaginary components
        polar: (%1 /_ %2) : create complex number using the last two operands as
            magnitude,phase components (phase in radians)
        real: real (%1) : real part of complex number
        imag: imag (%1) : imaginary part of complex number
        phase: phase (%1) : phase of complex number (use -abs for magnitude)
        conj: conj (%1) : complex conjugate
        proj: proj (%1) : projection onto the Riemann sphere
        exp: exp (%1) : exponential function
        log: log (%1) : natural logarithm
        log10: log10 (%1) : common logarithm
        cos: cos (%1) : cosine
        sin: sin (%1) : sine
        tan: tan (%1) : tangent
        acos: acos (%1) : inverse cosine
        asin: asin (%1) : inverse sine
        atan: atan (%1) : inverse tangent
        cosh: cosh (%1) : hyperbolic cosine
        sinh: sinh (%1) : hyperbolic sine
        tanh: tanh (%1) : hyperbolic tangent
        acosh: acosh (%1) : inverse hyperbolic cosine
        asinh: asinh (%1) : inverse hyperbolic sine
        atanh: atanh (%1) : inverse hyperbolic tangent
        datatype: specify output image data type. Valid choices are: float32,
            float32le, float32be, float64, float64le, float64be, int64, uint64,
            int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le,
            int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be,
            cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be,
            int8, uint8, bit.
        info: display information messages.
        quiet: do not display information messages or progress status;
            alternatively, this can be achieved by setting the MRTRIX_QUIET
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications (set
            to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
        runner: Command runner
    Returns:
        NamedTuple of outputs (described in `MrcalcOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRCALC_METADATA)
    cargs = []
    cargs.append("mrcalc")
    if abs_ is not None:
        cargs.extend(["-abs", *[a for c in [s.run(execution) for s in abs_] for a in c]])
    if neg is not None:
        cargs.extend(["-neg", *[a for c in [s.run(execution) for s in neg] for a in c]])
    if add is not None:
        cargs.extend(["-add", *[a for c in [s.run(execution) for s in add] for a in c]])
    if subtract is not None:
        cargs.extend(["-subtract", *[a for c in [s.run(execution) for s in subtract] for a in c]])
    if multiply is not None:
        cargs.extend(["-multiply", *[a for c in [s.run(execution) for s in multiply] for a in c]])
    if divide is not None:
        cargs.extend(["-divide", *[a for c in [s.run(execution) for s in divide] for a in c]])
    if min_ is not None:
        cargs.extend(["-min", *[a for c in [s.run(execution) for s in min_] for a in c]])
    if max_ is not None:
        cargs.extend(["-max", *[a for c in [s.run(execution) for s in max_] for a in c]])
    if lt is not None:
        cargs.extend(["-lt", *[a for c in [s.run(execution) for s in lt] for a in c]])
    if gt is not None:
        cargs.extend(["-gt", *[a for c in [s.run(execution) for s in gt] for a in c]])
    if le is not None:
        cargs.extend(["-le", *[a for c in [s.run(execution) for s in le] for a in c]])
    if ge is not None:
        cargs.extend(["-ge", *[a for c in [s.run(execution) for s in ge] for a in c]])
    if eq is not None:
        cargs.extend(["-eq", *[a for c in [s.run(execution) for s in eq] for a in c]])
    if neq is not None:
        cargs.extend(["-neq", *[a for c in [s.run(execution) for s in neq] for a in c]])
    if if_ is not None:
        cargs.extend(["-if", *[a for c in [s.run(execution) for s in if_] for a in c]])
    if replace is not None:
        cargs.extend(["-replace", *[a for c in [s.run(execution) for s in replace] for a in c]])
    if sqrt is not None:
        cargs.extend(["-sqrt", *[a for c in [s.run(execution) for s in sqrt] for a in c]])
    if pow_ is not None:
        cargs.extend(["-pow", *[a for c in [s.run(execution) for s in pow_] for a in c]])
    if round_ is not None:
        cargs.extend(["-round", *[a for c in [s.run(execution) for s in round_] for a in c]])
    if ceil is not None:
        cargs.extend(["-ceil", *[a for c in [s.run(execution) for s in ceil] for a in c]])
    if floor is not None:
        cargs.extend(["-floor", *[a for c in [s.run(execution) for s in floor] for a in c]])
    if not_ is not None:
        cargs.extend(["-not", *[a for c in [s.run(execution) for s in not_] for a in c]])
    if and_ is not None:
        cargs.extend(["-and", *[a for c in [s.run(execution) for s in and_] for a in c]])
    if or_ is not None:
        cargs.extend(["-or", *[a for c in [s.run(execution) for s in or_] for a in c]])
    if xor is not None:
        cargs.extend(["-xor", *[a for c in [s.run(execution) for s in xor] for a in c]])
    if isnan is not None:
        cargs.extend(["-isnan", *[a for c in [s.run(execution) for s in isnan] for a in c]])
    if isinf is not None:
        cargs.extend(["-isinf", *[a for c in [s.run(execution) for s in isinf] for a in c]])
    if finite is not None:
        cargs.extend(["-finite", *[a for c in [s.run(execution) for s in finite] for a in c]])
    if complex_ is not None:
        cargs.extend(["-complex", *[a for c in [s.run(execution) for s in complex_] for a in c]])
    if polar is not None:
        cargs.extend(["-polar", *[a for c in [s.run(execution) for s in polar] for a in c]])
    if real is not None:
        cargs.extend(["-real", *[a for c in [s.run(execution) for s in real] for a in c]])
    if imag is not None:
        cargs.extend(["-imag", *[a for c in [s.run(execution) for s in imag] for a in c]])
    if phase is not None:
        cargs.extend(["-phase", *[a for c in [s.run(execution) for s in phase] for a in c]])
    if conj is not None:
        cargs.extend(["-conj", *[a for c in [s.run(execution) for s in conj] for a in c]])
    if proj is not None:
        cargs.extend(["-proj", *[a for c in [s.run(execution) for s in proj] for a in c]])
    if exp is not None:
        cargs.extend(["-exp", *[a for c in [s.run(execution) for s in exp] for a in c]])
    if log is not None:
        cargs.extend(["-log", *[a for c in [s.run(execution) for s in log] for a in c]])
    if log10 is not None:
        cargs.extend(["-log10", *[a for c in [s.run(execution) for s in log10] for a in c]])
    if cos is not None:
        cargs.extend(["-cos", *[a for c in [s.run(execution) for s in cos] for a in c]])
    if sin is not None:
        cargs.extend(["-sin", *[a for c in [s.run(execution) for s in sin] for a in c]])
    if tan is not None:
        cargs.extend(["-tan", *[a for c in [s.run(execution) for s in tan] for a in c]])
    if acos is not None:
        cargs.extend(["-acos", *[a for c in [s.run(execution) for s in acos] for a in c]])
    if asin is not None:
        cargs.extend(["-asin", *[a for c in [s.run(execution) for s in asin] for a in c]])
    if atan is not None:
        cargs.extend(["-atan", *[a for c in [s.run(execution) for s in atan] for a in c]])
    if cosh is not None:
        cargs.extend(["-cosh", *[a for c in [s.run(execution) for s in cosh] for a in c]])
    if sinh is not None:
        cargs.extend(["-sinh", *[a for c in [s.run(execution) for s in sinh] for a in c]])
    if tanh is not None:
        cargs.extend(["-tanh", *[a for c in [s.run(execution) for s in tanh] for a in c]])
    if acosh is not None:
        cargs.extend(["-acosh", *[a for c in [s.run(execution) for s in acosh] for a in c]])
    if asinh is not None:
        cargs.extend(["-asinh", *[a for c in [s.run(execution) for s in asinh] for a in c]])
    if atanh is not None:
        cargs.extend(["-atanh", *[a for c in [s.run(execution) for s in atanh] for a in c]])
    if datatype is not None:
        cargs.extend(["-datatype", datatype])
    if info:
        cargs.append("-info")
    if quiet:
        cargs.append("-quiet")
    if debug:
        cargs.append("-debug")
    if force:
        cargs.append("-force")
    if nthreads is not None:
        cargs.extend(["-nthreads", str(nthreads)])
    if config is not None:
        cargs.extend(["-config", *[a for c in [s.run(execution) for s in config] for a in c]])
    if help_:
        cargs.append("-help")
    if version:
        cargs.append("-version")
    cargs.extend(["", *operand])
    ret = MrcalcOutputs(
        root=execution.output_file("."),
    )
    execution.run(cargs)
    return ret


__all__ = [
    "MRCALC_METADATA",
    "MrcalcAbs",
    "MrcalcAcos",
    "MrcalcAcosh",
    "MrcalcAdd",
    "MrcalcAnd",
    "MrcalcAsin",
    "MrcalcAsinh",
    "MrcalcAtan",
    "MrcalcAtanh",
    "MrcalcCeil",
    "MrcalcComplex",
    "MrcalcConfig",
    "MrcalcConj",
    "MrcalcCos",
    "MrcalcCosh",
    "MrcalcDivide",
    "MrcalcEq",
    "MrcalcExp",
    "MrcalcFinite",
    "MrcalcFloor",
    "MrcalcGe",
    "MrcalcGt",
    "MrcalcIf",
    "MrcalcImag",
    "MrcalcIsinf",
    "MrcalcIsnan",
    "MrcalcLe",
    "MrcalcLog",
    "MrcalcLog10",
    "MrcalcLt",
    "MrcalcMax",
    "MrcalcMin",
    "MrcalcMultiply",
    "MrcalcNeg",
    "MrcalcNeq",
    "MrcalcNot",
    "MrcalcOr",
    "MrcalcOutputs",
    "MrcalcPhase",
    "MrcalcPolar",
    "MrcalcPow",
    "MrcalcProj",
    "MrcalcReal",
    "MrcalcReplace",
    "MrcalcRound",
    "MrcalcSin",
    "MrcalcSinh",
    "MrcalcSqrt",
    "MrcalcSubtract",
    "MrcalcTan",
    "MrcalcTanh",
    "MrcalcXor",
    "mrcalc",
]
