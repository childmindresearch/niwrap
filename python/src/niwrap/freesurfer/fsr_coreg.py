# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *
import dataclasses

FSR_COREG_METADATA = Metadata(
    id="0db7d273024849f574cecf1dc48bd9ff97800d41.boutiques",
    name="fsr-coreg",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


class FsrCoregOutputs(typing.NamedTuple):
    """
    Output object returned when calling `fsr_coreg(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    aligned_volume: OutputPathType | None
    """Volume produced for each mode in alignment with the reference mode"""
    registration_transform: OutputPathType | None
    """Registration transform file for mode to reference mode"""


def fsr_coreg(
    import_dir: str,
    reference_mode: str,
    num_threads: float | None = None,
    force_update: bool = False,
    output_dir: str | None = None,
    expert_options: InputPathType | None = None,
    runner: Runner | None = None,
) -> FsrCoregOutputs:
    """
    Co-registers input data in preparation for FreeSurfer analysis.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        import_dir: Data directory created by fsr-import.
        reference_mode: Mode to use as a reference (all modes register to this\
            mode).
        num_threads: Number of threads to use.
        force_update: Force update of files regardless of time stamp.
        output_dir: Set the output directory, default is importdir.
        expert_options: Expert options file.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FsrCoregOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(FSR_COREG_METADATA)
    cargs = []
    cargs.append("fsr-coreg")
    cargs.append("--i")
    cargs.extend([
        "--i",
        import_dir
    ])
    cargs.append("--ref")
    cargs.extend([
        "--ref",
        reference_mode
    ])
    cargs.append("--threads")
    if num_threads is not None:
        cargs.extend([
            "--threads",
            str(num_threads)
        ])
    if force_update:
        cargs.append("--force-update")
    cargs.append("--o")
    if output_dir is not None:
        cargs.extend([
            "--o",
            output_dir
        ])
    cargs.append("--expert")
    if expert_options is not None:
        cargs.extend([
            "--expert",
            execution.input_file(expert_options)
        ])
    ret = FsrCoregOutputs(
        root=execution.output_file("."),
        aligned_volume=execution.output_file(output_dir + "/mode.mgz") if (output_dir is not None) else None,
        registration_transform=execution.output_file(output_dir + "/mode.reg-to-ref.lta") if (output_dir is not None) else None,
    )
    execution.run(cargs)
    return ret


__all__ = [
    "FSR_COREG_METADATA",
    "FsrCoregOutputs",
    "fsr_coreg",
]
