# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_EASYREG_METADATA = Metadata(
    id="a8597c7c31eb3d0db090b8c58b2eb2709f8b9b2d.boutiques",
    name="mri_easyreg",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)
MriEasyregParameters = typing.TypedDict('MriEasyregParameters', {
    "__STYX_TYPE__": typing.Literal["mri_easyreg"],
    "reference_image": InputPathType,
    "reference_segmentation": typing.NotRequired[InputPathType | None],
    "floating_image": InputPathType,
    "floating_segmentation": typing.NotRequired[InputPathType | None],
    "registered_reference": typing.NotRequired[InputPathType | None],
    "registered_floating": typing.NotRequired[InputPathType | None],
    "forward_field": typing.NotRequired[InputPathType | None],
    "inverse_field": typing.NotRequired[InputPathType | None],
    "affine_only": bool,
    "threads": typing.NotRequired[float | None],
})


def dyn_cargs(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "mri_easyreg": mri_easyreg_cargs,
    }.get(t)


def dyn_outputs(
    t: str,
) -> typing.Any:
    """
    Get build outputs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build outputs function.
    """
    return {
        "mri_easyreg": mri_easyreg_outputs,
    }.get(t)


class MriEasyregOutputs(typing.NamedTuple):
    """
    Output object returned when calling `mri_easyreg(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    registered_reference_output: OutputPathType
    """Output registered reference image"""
    registered_floating_output: OutputPathType
    """Output registered floating image"""
    forward_field_output: OutputPathType
    """Output forward field file"""
    inverse_field_output: OutputPathType
    """Output inverse field file"""


def mri_easyreg_params(
    reference_image: InputPathType,
    floating_image: InputPathType,
    reference_segmentation: InputPathType | None = None,
    floating_segmentation: InputPathType | None = None,
    registered_reference: InputPathType | None = None,
    registered_floating: InputPathType | None = None,
    forward_field: InputPathType | None = None,
    inverse_field: InputPathType | None = None,
    affine_only: bool = False,
    threads: float | None = None,
) -> MriEasyregParameters:
    """
    Build parameters.
    
    Args:
        reference_image: Reference image.
        floating_image: Floating image.
        reference_segmentation: Reference SynthSeg segmentation (will be\
            created if it does not exist).
        floating_segmentation: Floating SynthSeg segmentation (will be created\
            if it does not exist).
        registered_reference: (optional) Registered reference.
        registered_floating: (optional) Registered floating images (in space of\
            reference).
        forward_field: (optional) Forward field.
        inverse_field: (optional) Inverse field.
        affine_only: (optional) Skips nonlinear part.
        threads: (optional) Number of cores to be used. Default is 1. You can\
            use -1 to use all available cores.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "mri_easyreg",
        "reference_image": reference_image,
        "floating_image": floating_image,
        "affine_only": affine_only,
    }
    if reference_segmentation is not None:
        params["reference_segmentation"] = reference_segmentation
    if floating_segmentation is not None:
        params["floating_segmentation"] = floating_segmentation
    if registered_reference is not None:
        params["registered_reference"] = registered_reference
    if registered_floating is not None:
        params["registered_floating"] = registered_floating
    if forward_field is not None:
        params["forward_field"] = forward_field
    if inverse_field is not None:
        params["inverse_field"] = inverse_field
    if threads is not None:
        params["threads"] = threads
    return params


def mri_easyreg_cargs(
    params: MriEasyregParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_easyreg")
    cargs.extend([
        "--ref",
        execution.input_file(params.get("reference_image"))
    ])
    if params.get("reference_segmentation") is not None:
        cargs.extend([
            "--ref_seg",
            execution.input_file(params.get("reference_segmentation"))
        ])
    cargs.extend([
        "--flo",
        execution.input_file(params.get("floating_image"))
    ])
    if params.get("floating_segmentation") is not None:
        cargs.extend([
            "--flo_seg",
            execution.input_file(params.get("floating_segmentation"))
        ])
    if params.get("registered_reference") is not None:
        cargs.extend([
            "--ref_reg",
            execution.input_file(params.get("registered_reference"))
        ])
    if params.get("registered_floating") is not None:
        cargs.extend([
            "--flo_reg",
            execution.input_file(params.get("registered_floating"))
        ])
    if params.get("forward_field") is not None:
        cargs.extend([
            "--fwd_field",
            execution.input_file(params.get("forward_field"))
        ])
    if params.get("inverse_field") is not None:
        cargs.extend([
            "--bak_field",
            execution.input_file(params.get("inverse_field"))
        ])
    if params.get("affine_only"):
        cargs.append("--affine_only")
    if params.get("threads") is not None:
        cargs.extend([
            "--threads",
            str(params.get("threads"))
        ])
    return cargs


def mri_easyreg_outputs(
    params: MriEasyregParameters,
    execution: Execution,
) -> MriEasyregOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriEasyregOutputs(
        root=execution.output_file("."),
        registered_reference_output=execution.output_file("registered_reference.nii.gz"),
        registered_floating_output=execution.output_file("registered_floating.nii.gz"),
        forward_field_output=execution.output_file("forward_field.nii.gz"),
        inverse_field_output=execution.output_file("inverse_field.nii.gz"),
    )
    return ret


def mri_easyreg_execute(
    params: MriEasyregParameters,
    execution: Execution,
) -> MriEasyregOutputs:
    """
    EasyReg: deep learning registration simple and easy.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        execution: The execution object.
    Returns:
        NamedTuple of outputs (described in `MriEasyregOutputs`).
    """
    # validate constraint checks (or after middlewares?)
    cargs = mri_easyreg_cargs(params, execution)
    ret = mri_easyreg_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_easyreg(
    reference_image: InputPathType,
    floating_image: InputPathType,
    reference_segmentation: InputPathType | None = None,
    floating_segmentation: InputPathType | None = None,
    registered_reference: InputPathType | None = None,
    registered_floating: InputPathType | None = None,
    forward_field: InputPathType | None = None,
    inverse_field: InputPathType | None = None,
    affine_only: bool = False,
    threads: float | None = None,
    runner: Runner | None = None,
) -> MriEasyregOutputs:
    """
    EasyReg: deep learning registration simple and easy.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        reference_image: Reference image.
        floating_image: Floating image.
        reference_segmentation: Reference SynthSeg segmentation (will be\
            created if it does not exist).
        floating_segmentation: Floating SynthSeg segmentation (will be created\
            if it does not exist).
        registered_reference: (optional) Registered reference.
        registered_floating: (optional) Registered floating images (in space of\
            reference).
        forward_field: (optional) Forward field.
        inverse_field: (optional) Inverse field.
        affine_only: (optional) Skips nonlinear part.
        threads: (optional) Number of cores to be used. Default is 1. You can\
            use -1 to use all available cores.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriEasyregOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_EASYREG_METADATA)
    params = mri_easyreg_params(reference_image=reference_image, reference_segmentation=reference_segmentation, floating_image=floating_image, floating_segmentation=floating_segmentation, registered_reference=registered_reference, registered_floating=registered_floating, forward_field=forward_field, inverse_field=inverse_field, affine_only=affine_only, threads=threads)
    return mri_easyreg_execute(params, execution)


__all__ = [
    "MRI_EASYREG_METADATA",
    "MriEasyregOutputs",
    "MriEasyregParameters",
    "mri_easyreg",
    "mri_easyreg_params",
]
