# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRIS_PLACE_SURFACE_METADATA = Metadata(
    id="e4e973bfe64ca5b7e38915757ccc306ea96b6327.boutiques",
    name="mris_place_surface",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)
MrisPlaceSurfaceParameters = typing.TypedDict('MrisPlaceSurfaceParameters', {
    "__STYX_TYPE__": typing.Literal["mris_place_surface"],
    "output_surface": str,
    "input_surface": str,
    "autodetect_gray_white_stats": str,
    "input_volume": str,
    "surface_type_group": typing.Literal["--white", "--pial"],
    "hemi_group": typing.Literal["--lh", "--rh"],
    "wm_segment": typing.NotRequired[str | None],
    "out_volume": typing.NotRequired[str | None],
    "out_volume_only": typing.NotRequired[str | None],
    "restore_255": bool,
    "segmentation": typing.NotRequired[str | None],
    "cortical_parcellation": typing.NotRequired[str | None],
    "nsmooth": typing.NotRequired[float | None],
    "smooth_after_rip": bool,
    "max_cbv_dist": typing.NotRequired[float | None],
    "rip_label": typing.NotRequired[str | None],
    "rip_midline": bool,
    "rip_bg": bool,
    "rip_bg_no_annot": bool,
    "no_rip_freeze": bool,
    "rip_wmsa": bool,
    "rip_lesion": bool,
    "no_rip": bool,
    "rip_overlay": typing.NotRequired[str | None],
    "rip_surface": typing.NotRequired[str | None],
    "rip_projection": typing.NotRequired[list[float] | None],
    "repulse_surface": typing.NotRequired[str | None],
    "white_surface": typing.NotRequired[str | None],
    "blend_surface": typing.NotRequired[str | None],
    "multimodal_input": typing.NotRequired[str | None],
    "mm_refine": bool,
    "pin_medial_wall": typing.NotRequired[str | None],
    "no_intensity_proc": bool,
    "debug_vertex": typing.NotRequired[float | None],
    "ripflag_out": typing.NotRequired[str | None],
    "local_max": typing.NotRequired[str | None],
    "target_surf": typing.NotRequired[str | None],
    "stop_mask": bool,
    "mm_intensity_limits": typing.NotRequired[str | None],
    "cover_seg": typing.NotRequired[str | None],
    "first_peak_d1": bool,
    "first_peak_d2": bool,
    "white_border_low_factor": typing.NotRequired[float | None],
    "fill_lateral_ventricles": typing.NotRequired[list[float] | None],
})


def dyn_cargs(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "mris_place_surface": mris_place_surface_cargs,
    }.get(t)


def dyn_outputs(
    t: str,
) -> typing.Any:
    """
    Get build outputs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build outputs function.
    """
    return {
    }.get(t)


class MrisPlaceSurfaceOutputs(typing.NamedTuple):
    """
    Output object returned when calling `mris_place_surface(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mris_place_surface_params(
    output_surface: str,
    input_surface: str,
    autodetect_gray_white_stats: str,
    input_volume: str,
    surface_type_group: typing.Literal["--white", "--pial"],
    hemi_group: typing.Literal["--lh", "--rh"],
    wm_segment: str | None = None,
    out_volume: str | None = None,
    out_volume_only: str | None = None,
    restore_255: bool = False,
    segmentation: str | None = None,
    cortical_parcellation: str | None = None,
    nsmooth: float | None = None,
    smooth_after_rip: bool = False,
    max_cbv_dist: float | None = None,
    rip_label: str | None = None,
    rip_midline: bool = False,
    rip_bg: bool = False,
    rip_bg_no_annot: bool = False,
    no_rip_freeze: bool = False,
    rip_wmsa: bool = False,
    rip_lesion: bool = False,
    no_rip: bool = False,
    rip_overlay: str | None = None,
    rip_surface: str | None = None,
    rip_projection: list[float] | None = None,
    repulse_surface: str | None = None,
    white_surface: str | None = None,
    blend_surface: str | None = None,
    multimodal_input: str | None = None,
    mm_refine: bool = False,
    pin_medial_wall: str | None = None,
    no_intensity_proc: bool = False,
    debug_vertex: float | None = None,
    ripflag_out: str | None = None,
    local_max: str | None = None,
    target_surf: str | None = None,
    stop_mask: bool = False,
    mm_intensity_limits: str | None = None,
    cover_seg: str | None = None,
    first_peak_d1: bool = False,
    first_peak_d2: bool = False,
    white_border_low_factor: float | None = None,
    fill_lateral_ventricles: list[float] | None = None,
) -> MrisPlaceSurfaceParameters:
    """
    Build parameters.
    
    Args:
        output_surface: Output surface.
        input_surface: Input surface.
        autodetect_gray_white_stats: Intensity stats created by\
            mris_autodet_gwstats.
        input_volume: T1-weighed intensity volume used to find white/gray/csf\
            gradients (usually brain.finalsurf.mgz).
        surface_type_group: Place the white surface or the pial surface. Must\
            choose one.
        hemi_group: Left or right hemisphere. Must choose one.
        wm_segment: White matter segmentation.
        out_volume: Save input volume after preprocessing.
        out_volume_only: Save input volume after preprocessing and then exit.
        restore_255: Set voxels in the input volume that start off as 255 to\
            110 (white surf only).
        segmentation: Whole-brain segmentation (usually aseg.presurf.mgz).
        cortical_parcellation: Set cortical parcellation used to rip vertices\
            (usually ?h.aparc.annot).
        nsmooth: Smooth input surface by number of iterations.
        smooth_after_rip: Smooth after ripping.
        max_cbv_dist: Limit distance MRIScomputeBorderValues() can search from\
            the input.
        rip_label: Do not move vertices that are NOT in the cortex label.
        rip_midline: Do not move vertices that are in the midline as indicated\
            by the seg.
        rip_bg: Do not move vertices near basal ganglia (as defined by seg).
        rip_bg_no_annot: Do not require surface have an annotation when ripping\
            BG.
        no_rip_freeze: Do NOT move vertices in/near freeze voxels (247 as\
            defined in seg).
        rip_wmsa: Do not move vertices in/near white-matter signal\
            abnormalities (77,78,79 as defined in seg).
        rip_lesion: Do not move vertices in/near lesions (25 and 57 as defined\
            in seg).
        no_rip: Turn off all ripping.
        rip_overlay: Rip vertices > 0.5 in the surface overlay file.
        rip_surface: Use this surface with ripping midline, BG, Freezes,\
            Lesions, and WMSA.
        rip_projection: Control projection depth along normal to ripsurface\
            when sampling seg.
        repulse_surface: Force input surface away from this surface (usually\
            the white surface when placing the pial).
        white_surface: Set the white{xyz} coordinates of the input surface\
            using this surface.
        blend_surface: Recompute the xyz coordinates of the input surface by\
            computing a weighted average with the blend surface.
        multimodal_input: Specify a T2 or FLAIR input volume used for placing\
            the pial surface. Must be in registration with the input volume.
        mm_refine: Use Siless' MultimodalRefinement. Sets tspring=nspring=0.3.
        pin_medial_wall: Set coordinates in vertices NOT in cortexlabel to be\
            that of the white{xyz} coordinates.
        no_intensity_proc: Do not process the input intensity volume (eg, to\
            remove parts of eye socket).
        debug_vertex: Debug vertex number.
        ripflag_out: Save ripflag as overlay.
        local_max: Save LocalMaxFoundFlag as overlay.
        target_surf: Save CBV target surface.
        stop_mask: Stop mask to stop search along normal for max gradient.
        mm_intensity_limits: Intensity limits for placing pial on multimodal\
            input.
        cover_seg: Force surface to cover the segmentation.
        first_peak_d1: Use find-first-peak option with 1st derivative in\
            ComputeBorderValues.
        first_peak_d2: Use find-first-peak option with 2nd derivative in\
            ComputeBorderValues.
        white_border_low_factor: white_border_low = f*adgws.gray_mean +\
            (1-f)*adgws.white_mean;.
        fill_lateral_ventricles: Fill lateral ventricles with 110.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "mris_place_surface",
        "output_surface": output_surface,
        "input_surface": input_surface,
        "autodetect_gray_white_stats": autodetect_gray_white_stats,
        "input_volume": input_volume,
        "surface_type_group": surface_type_group,
        "hemi_group": hemi_group,
        "restore_255": restore_255,
        "smooth_after_rip": smooth_after_rip,
        "rip_midline": rip_midline,
        "rip_bg": rip_bg,
        "rip_bg_no_annot": rip_bg_no_annot,
        "no_rip_freeze": no_rip_freeze,
        "rip_wmsa": rip_wmsa,
        "rip_lesion": rip_lesion,
        "no_rip": no_rip,
        "mm_refine": mm_refine,
        "no_intensity_proc": no_intensity_proc,
        "stop_mask": stop_mask,
        "first_peak_d1": first_peak_d1,
        "first_peak_d2": first_peak_d2,
    }
    if wm_segment is not None:
        params["wm_segment"] = wm_segment
    if out_volume is not None:
        params["out_volume"] = out_volume
    if out_volume_only is not None:
        params["out_volume_only"] = out_volume_only
    if segmentation is not None:
        params["segmentation"] = segmentation
    if cortical_parcellation is not None:
        params["cortical_parcellation"] = cortical_parcellation
    if nsmooth is not None:
        params["nsmooth"] = nsmooth
    if max_cbv_dist is not None:
        params["max_cbv_dist"] = max_cbv_dist
    if rip_label is not None:
        params["rip_label"] = rip_label
    if rip_overlay is not None:
        params["rip_overlay"] = rip_overlay
    if rip_surface is not None:
        params["rip_surface"] = rip_surface
    if rip_projection is not None:
        params["rip_projection"] = rip_projection
    if repulse_surface is not None:
        params["repulse_surface"] = repulse_surface
    if white_surface is not None:
        params["white_surface"] = white_surface
    if blend_surface is not None:
        params["blend_surface"] = blend_surface
    if multimodal_input is not None:
        params["multimodal_input"] = multimodal_input
    if pin_medial_wall is not None:
        params["pin_medial_wall"] = pin_medial_wall
    if debug_vertex is not None:
        params["debug_vertex"] = debug_vertex
    if ripflag_out is not None:
        params["ripflag_out"] = ripflag_out
    if local_max is not None:
        params["local_max"] = local_max
    if target_surf is not None:
        params["target_surf"] = target_surf
    if mm_intensity_limits is not None:
        params["mm_intensity_limits"] = mm_intensity_limits
    if cover_seg is not None:
        params["cover_seg"] = cover_seg
    if white_border_low_factor is not None:
        params["white_border_low_factor"] = white_border_low_factor
    if fill_lateral_ventricles is not None:
        params["fill_lateral_ventricles"] = fill_lateral_ventricles
    return params


def mris_place_surface_cargs(
    params: MrisPlaceSurfaceParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mris_place_surface")
    cargs.extend([
        "--o",
        params.get("output_surface")
    ])
    cargs.extend([
        "--i",
        params.get("input_surface")
    ])
    cargs.extend([
        "--adgw",
        params.get("autodetect_gray_white_stats")
    ])
    cargs.extend([
        "--invol",
        params.get("input_volume")
    ])
    cargs.append(params.get("surface_type_group"))
    cargs.append(params.get("hemi_group"))
    if params.get("wm_segment") is not None:
        cargs.extend([
            "--wm",
            params.get("wm_segment")
        ])
    if params.get("out_volume") is not None:
        cargs.extend([
            "--outvol",
            params.get("out_volume")
        ])
    if params.get("out_volume_only") is not None:
        cargs.extend([
            "--outvol-only",
            params.get("out_volume_only")
        ])
    if params.get("restore_255"):
        cargs.append("--restore-255")
    if params.get("segmentation") is not None:
        cargs.extend([
            "--seg",
            params.get("segmentation")
        ])
    if params.get("cortical_parcellation") is not None:
        cargs.extend([
            "--aparc",
            params.get("cortical_parcellation")
        ])
    if params.get("nsmooth") is not None:
        cargs.extend([
            "--nsmooth",
            str(params.get("nsmooth"))
        ])
    if params.get("smooth_after_rip"):
        cargs.append("--smooth-after-rip")
    if params.get("max_cbv_dist") is not None:
        cargs.extend([
            "--max-cbv-dist",
            str(params.get("max_cbv_dist"))
        ])
    if params.get("rip_label") is not None:
        cargs.extend([
            "--rip-label",
            params.get("rip_label")
        ])
    if params.get("rip_midline"):
        cargs.append("--rip-midline")
    if params.get("rip_bg"):
        cargs.append("--rip-bg")
    if params.get("rip_bg_no_annot"):
        cargs.append("--rip-bg-no-annot")
    if params.get("no_rip_freeze"):
        cargs.append("--no-rip-freeze")
    if params.get("rip_wmsa"):
        cargs.append("--rip-wmsa")
    if params.get("rip_lesion"):
        cargs.append("--rip-lesion")
    if params.get("no_rip"):
        cargs.append("--no-rip")
    if params.get("rip_overlay") is not None:
        cargs.extend([
            "--rip-overlay",
            params.get("rip_overlay")
        ])
    if params.get("rip_surface") is not None:
        cargs.extend([
            "--ripsurface",
            params.get("rip_surface")
        ])
    if params.get("rip_projection") is not None:
        cargs.extend([
            "--rip-projection",
            *map(str, params.get("rip_projection"))
        ])
    if params.get("repulse_surface") is not None:
        cargs.extend([
            "--repulse-surf",
            params.get("repulse_surface")
        ])
    if params.get("white_surface") is not None:
        cargs.extend([
            "--white-surf",
            params.get("white_surface")
        ])
    if params.get("blend_surface") is not None:
        cargs.extend([
            "--blend-surf",
            params.get("blend_surface")
        ])
    if params.get("multimodal_input") is not None:
        cargs.extend([
            "--mmvol",
            params.get("multimodal_input")
        ])
    if params.get("mm_refine"):
        cargs.append("--mm-refine")
    if params.get("pin_medial_wall") is not None:
        cargs.extend([
            "--pin-medial-wall",
            params.get("pin_medial_wall")
        ])
    if params.get("no_intensity_proc"):
        cargs.append("--no-intensity-proc")
    if params.get("debug_vertex") is not None:
        cargs.extend([
            "--debug-vertex",
            str(params.get("debug_vertex"))
        ])
    if params.get("ripflag_out") is not None:
        cargs.extend([
            "--ripflag-out",
            params.get("ripflag_out")
        ])
    if params.get("local_max") is not None:
        cargs.extend([
            "--local-max",
            params.get("local_max")
        ])
    if params.get("target_surf") is not None:
        cargs.extend([
            "--target",
            params.get("target_surf")
        ])
    if params.get("stop_mask"):
        cargs.append("--stop")
    if params.get("mm_intensity_limits") is not None:
        cargs.extend([
            "--mm_{min,max}_{inside,outside}",
            params.get("mm_intensity_limits")
        ])
    if params.get("cover_seg") is not None:
        cargs.extend([
            "--cover-seg",
            params.get("cover_seg")
        ])
    if params.get("first_peak_d1"):
        cargs.append("--first-peak-d1")
    if params.get("first_peak_d2"):
        cargs.append("--first-peak-d2")
    if params.get("white_border_low_factor") is not None:
        cargs.extend([
            "--white_border_low_factor",
            str(params.get("white_border_low_factor"))
        ])
    if params.get("fill_lateral_ventricles") is not None:
        cargs.extend([
            "--fill-lat-vents",
            *map(str, params.get("fill_lateral_ventricles"))
        ])
    cargs.append("[COST_FUNCTION_ARGS]")
    return cargs


def mris_place_surface_outputs(
    params: MrisPlaceSurfaceParameters,
    execution: Execution,
) -> MrisPlaceSurfaceOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MrisPlaceSurfaceOutputs(
        root=execution.output_file("."),
    )
    return ret


def mris_place_surface_execute(
    params: MrisPlaceSurfaceParameters,
    execution: Execution,
) -> MrisPlaceSurfaceOutputs:
    """
    This program positions the triangular mesh representing a cortical surface,
    either the 'white' surface (ie, white/gray boundary) or the 'pial' surface (ie,
    the gray/csf boundary).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        execution: The execution object.
    Returns:
        NamedTuple of outputs (described in `MrisPlaceSurfaceOutputs`).
    """
    cargs = mris_place_surface_cargs(params, execution)
    ret = mris_place_surface_outputs(params, execution)
    execution.run(cargs)
    return ret


def mris_place_surface(
    output_surface: str,
    input_surface: str,
    autodetect_gray_white_stats: str,
    input_volume: str,
    surface_type_group: typing.Literal["--white", "--pial"],
    hemi_group: typing.Literal["--lh", "--rh"],
    wm_segment: str | None = None,
    out_volume: str | None = None,
    out_volume_only: str | None = None,
    restore_255: bool = False,
    segmentation: str | None = None,
    cortical_parcellation: str | None = None,
    nsmooth: float | None = None,
    smooth_after_rip: bool = False,
    max_cbv_dist: float | None = None,
    rip_label: str | None = None,
    rip_midline: bool = False,
    rip_bg: bool = False,
    rip_bg_no_annot: bool = False,
    no_rip_freeze: bool = False,
    rip_wmsa: bool = False,
    rip_lesion: bool = False,
    no_rip: bool = False,
    rip_overlay: str | None = None,
    rip_surface: str | None = None,
    rip_projection: list[float] | None = None,
    repulse_surface: str | None = None,
    white_surface: str | None = None,
    blend_surface: str | None = None,
    multimodal_input: str | None = None,
    mm_refine: bool = False,
    pin_medial_wall: str | None = None,
    no_intensity_proc: bool = False,
    debug_vertex: float | None = None,
    ripflag_out: str | None = None,
    local_max: str | None = None,
    target_surf: str | None = None,
    stop_mask: bool = False,
    mm_intensity_limits: str | None = None,
    cover_seg: str | None = None,
    first_peak_d1: bool = False,
    first_peak_d2: bool = False,
    white_border_low_factor: float | None = None,
    fill_lateral_ventricles: list[float] | None = None,
    runner: Runner | None = None,
) -> MrisPlaceSurfaceOutputs:
    """
    This program positions the triangular mesh representing a cortical surface,
    either the 'white' surface (ie, white/gray boundary) or the 'pial' surface (ie,
    the gray/csf boundary).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        output_surface: Output surface.
        input_surface: Input surface.
        autodetect_gray_white_stats: Intensity stats created by\
            mris_autodet_gwstats.
        input_volume: T1-weighed intensity volume used to find white/gray/csf\
            gradients (usually brain.finalsurf.mgz).
        surface_type_group: Place the white surface or the pial surface. Must\
            choose one.
        hemi_group: Left or right hemisphere. Must choose one.
        wm_segment: White matter segmentation.
        out_volume: Save input volume after preprocessing.
        out_volume_only: Save input volume after preprocessing and then exit.
        restore_255: Set voxels in the input volume that start off as 255 to\
            110 (white surf only).
        segmentation: Whole-brain segmentation (usually aseg.presurf.mgz).
        cortical_parcellation: Set cortical parcellation used to rip vertices\
            (usually ?h.aparc.annot).
        nsmooth: Smooth input surface by number of iterations.
        smooth_after_rip: Smooth after ripping.
        max_cbv_dist: Limit distance MRIScomputeBorderValues() can search from\
            the input.
        rip_label: Do not move vertices that are NOT in the cortex label.
        rip_midline: Do not move vertices that are in the midline as indicated\
            by the seg.
        rip_bg: Do not move vertices near basal ganglia (as defined by seg).
        rip_bg_no_annot: Do not require surface have an annotation when ripping\
            BG.
        no_rip_freeze: Do NOT move vertices in/near freeze voxels (247 as\
            defined in seg).
        rip_wmsa: Do not move vertices in/near white-matter signal\
            abnormalities (77,78,79 as defined in seg).
        rip_lesion: Do not move vertices in/near lesions (25 and 57 as defined\
            in seg).
        no_rip: Turn off all ripping.
        rip_overlay: Rip vertices > 0.5 in the surface overlay file.
        rip_surface: Use this surface with ripping midline, BG, Freezes,\
            Lesions, and WMSA.
        rip_projection: Control projection depth along normal to ripsurface\
            when sampling seg.
        repulse_surface: Force input surface away from this surface (usually\
            the white surface when placing the pial).
        white_surface: Set the white{xyz} coordinates of the input surface\
            using this surface.
        blend_surface: Recompute the xyz coordinates of the input surface by\
            computing a weighted average with the blend surface.
        multimodal_input: Specify a T2 or FLAIR input volume used for placing\
            the pial surface. Must be in registration with the input volume.
        mm_refine: Use Siless' MultimodalRefinement. Sets tspring=nspring=0.3.
        pin_medial_wall: Set coordinates in vertices NOT in cortexlabel to be\
            that of the white{xyz} coordinates.
        no_intensity_proc: Do not process the input intensity volume (eg, to\
            remove parts of eye socket).
        debug_vertex: Debug vertex number.
        ripflag_out: Save ripflag as overlay.
        local_max: Save LocalMaxFoundFlag as overlay.
        target_surf: Save CBV target surface.
        stop_mask: Stop mask to stop search along normal for max gradient.
        mm_intensity_limits: Intensity limits for placing pial on multimodal\
            input.
        cover_seg: Force surface to cover the segmentation.
        first_peak_d1: Use find-first-peak option with 1st derivative in\
            ComputeBorderValues.
        first_peak_d2: Use find-first-peak option with 2nd derivative in\
            ComputeBorderValues.
        white_border_low_factor: white_border_low = f*adgws.gray_mean +\
            (1-f)*adgws.white_mean;.
        fill_lateral_ventricles: Fill lateral ventricles with 110.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrisPlaceSurfaceOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRIS_PLACE_SURFACE_METADATA)
    params = mris_place_surface_params(output_surface=output_surface, input_surface=input_surface, autodetect_gray_white_stats=autodetect_gray_white_stats, input_volume=input_volume, surface_type_group=surface_type_group, hemi_group=hemi_group, wm_segment=wm_segment, out_volume=out_volume, out_volume_only=out_volume_only, restore_255=restore_255, segmentation=segmentation, cortical_parcellation=cortical_parcellation, nsmooth=nsmooth, smooth_after_rip=smooth_after_rip, max_cbv_dist=max_cbv_dist, rip_label=rip_label, rip_midline=rip_midline, rip_bg=rip_bg, rip_bg_no_annot=rip_bg_no_annot, no_rip_freeze=no_rip_freeze, rip_wmsa=rip_wmsa, rip_lesion=rip_lesion, no_rip=no_rip, rip_overlay=rip_overlay, rip_surface=rip_surface, rip_projection=rip_projection, repulse_surface=repulse_surface, white_surface=white_surface, blend_surface=blend_surface, multimodal_input=multimodal_input, mm_refine=mm_refine, pin_medial_wall=pin_medial_wall, no_intensity_proc=no_intensity_proc, debug_vertex=debug_vertex, ripflag_out=ripflag_out, local_max=local_max, target_surf=target_surf, stop_mask=stop_mask, mm_intensity_limits=mm_intensity_limits, cover_seg=cover_seg, first_peak_d1=first_peak_d1, first_peak_d2=first_peak_d2, white_border_low_factor=white_border_low_factor, fill_lateral_ventricles=fill_lateral_ventricles)
    return mris_place_surface_execute(params, execution)


__all__ = [
    "MRIS_PLACE_SURFACE_METADATA",
    "MrisPlaceSurfaceOutputs",
    "MrisPlaceSurfaceParameters",
    "mris_place_surface",
    "mris_place_surface_params",
]
