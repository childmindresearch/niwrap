# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *
import dataclasses

GREEDY_METADATA = Metadata(
    id="81e25c6c4fb84453185826b4258b91dafaf56f30.boutiques",
    name="greedy",
    package="greedy",
    container_image_tag="pyushkevich/itksnap:v3.8.2",
)
GreedyInputImagesParameters = typing.TypedDict('GreedyInputImagesParameters', {
    "__STYX_TYPE__": typing.Literal["input_images"],
    "fixed": InputPathType,
    "moving": InputPathType,
})
GreedyInvertParameters = typing.TypedDict('GreedyInvertParameters', {
    "__STYX_TYPE__": typing.Literal["invert"],
    "inwarp": InputPathType,
    "outwarp": str,
})
GreedyRootParameters = typing.TypedDict('GreedyRootParameters', {
    "__STYX_TYPE__": typing.Literal["root"],
    "inwarp": InputPathType,
    "outwarp": str,
    "n": int,
})
GreedyJacobianParameters = typing.TypedDict('GreedyJacobianParameters', {
    "__STYX_TYPE__": typing.Literal["jacobian"],
    "inwarp": InputPathType,
    "outjac": str,
})
GreedyMetricParameters = typing.TypedDict('GreedyMetricParameters', {
    "__STYX_TYPE__": typing.Literal["metric"],
    "metric_type": typing.Literal["SSD", "MI", "NMI", "NCC", "MAHAL"],
    "metric_param": typing.NotRequired[float | None],
})
GreedyTjrParameters = typing.TypedDict('GreedyTjrParameters', {
    "__STYX_TYPE__": typing.Literal["tjr"],
    "mesh": InputPathType,
    "weight": float,
})
GreedySearchParameters = typing.TypedDict('GreedySearchParameters', {
    "__STYX_TYPE__": typing.Literal["search"],
    "n": int,
    "rot": str,
    "tran": float,
})
GreedyResliceMovingImageParameters = typing.TypedDict('GreedyResliceMovingImageParameters', {
    "__STYX_TYPE__": typing.Literal["reslice_moving_image"],
    "moving": InputPathType,
    "output": str,
})
GreedyResliceSurfaceParameters = typing.TypedDict('GreedyResliceSurfaceParameters', {
    "__STYX_TYPE__": typing.Literal["reslice_surface"],
    "inmesh": InputPathType,
    "outmesh": str,
})
GreedyResliceSimplexJacobianParameters = typing.TypedDict('GreedyResliceSimplexJacobianParameters', {
    "__STYX_TYPE__": typing.Literal["reslice_simplex_jacobian"],
    "inmesh": InputPathType,
    "outmesh": str,
})
GreedyParameters = typing.TypedDict('GreedyParameters', {
    "__STYX_TYPE__": typing.Literal["greedy"],
    "dimensions": int,
    "input_images": typing.NotRequired[GreedyInputImagesParameters | None],
    "output": typing.NotRequired[str | None],
    "affine": bool,
    "brute": typing.NotRequired[str | None],
    "moments": typing.NotRequired[typing.Literal[1, 2] | None],
    "reslice": typing.NotRequired[list[InputPathType] | None],
    "invert": typing.NotRequired[GreedyInvertParameters | None],
    "root": typing.NotRequired[GreedyRootParameters | None],
    "jacobian": typing.NotRequired[GreedyJacobianParameters | None],
    "metric_mode": bool,
    "defopt": bool,
    "weight": typing.NotRequired[float | None],
    "metric": typing.NotRequired[GreedyMetricParameters | None],
    "step_size": typing.NotRequired[str | None],
    "iterations": typing.NotRequired[str | None],
    "threads": typing.NotRequired[int | None],
    "fixed_mask": typing.NotRequired[InputPathType | None],
    "gm_trim": typing.NotRequired[float | None],
    "moving_mask": typing.NotRequired[InputPathType | None],
    "wncc_mask_dilate": bool,
    "reference_image": typing.NotRequired[InputPathType | None],
    "ref_pad": typing.NotRequired[float | None],
    "background": typing.NotRequired[str | None],
    "input_transform": typing.NotRequired[InputPathType | None],
    "zero_last_dimension": bool,
    "time_step_mode": typing.NotRequired[typing.Literal["CONST", "SCALE", "SCALEDOWN"] | None],
    "smoothing": typing.NotRequired[str | None],
    "inverse_warp": typing.NotRequired[InputPathType | None],
    "root_warp": typing.NotRequired[InputPathType | None],
    "warp_precision": typing.NotRequired[float | None],
    "noise": typing.NotRequired[float | None],
    "exponent": typing.NotRequired[float | None],
    "svf_mode": bool,
    "svlb": bool,
    "sv_incompr": bool,
    "initial_warp": typing.NotRequired[InputPathType | None],
    "tjr": typing.NotRequired[GreedyTjrParameters | None],
    "wr": typing.NotRequired[float | None],
    "initial_affine": typing.NotRequired[InputPathType | None],
    "ia_identity": bool,
    "ia_voxel_grid": bool,
    "ia_image_centers": bool,
    "ia_image_side": typing.NotRequired[str | None],
    "ia_moments": typing.NotRequired[typing.Literal[1, 2] | None],
    "affine_dof": typing.NotRequired[typing.Literal[6, 7, 12] | None],
    "jitter": typing.NotRequired[float | None],
    "search": typing.NotRequired[GreedySearchParameters | None],
    "det": typing.NotRequired[typing.Literal[-1, 1] | None],
    "cov_id": bool,
    "fixed_reslicing_image": typing.NotRequired[InputPathType | None],
    "reslice_moving_image": typing.NotRequired[GreedyResliceMovingImageParameters | None],
    "reslice_surface": typing.NotRequired[GreedyResliceSurfaceParameters | None],
    "interpolation": typing.NotRequired[typing.Literal["NN", "LINEAR", "LABEL"] | None],
    "reslice_background": typing.NotRequired[float | None],
    "reslice_datatype": typing.NotRequired[typing.Literal["auto", "double", "float", "uint", "int", "ushort", "short", "uchar", "char"] | None],
    "reslice_composite": typing.NotRequired[InputPathType | None],
    "reslice_jacobian": typing.NotRequired[InputPathType | None],
    "reslice_simplex_jacobian": typing.NotRequired[GreedyResliceSimplexJacobianParameters | None],
    "reslice_mask": typing.NotRequired[InputPathType | None],
    "metric_gradient": typing.NotRequired[InputPathType | None],
    "debug_deriv": bool,
    "debug_deriv_eps": typing.NotRequired[float | None],
    "debug_aff_obj": bool,
    "dump_pyramid": bool,
    "dump_moving": bool,
    "dump_frequency": typing.NotRequired[float | None],
    "dump_prefix": typing.NotRequired[str | None],
    "powell": bool,
    "float": bool,
    "version": bool,
    "verbosity": typing.NotRequired[typing.Literal[0, 1, 2] | None],
})


def dyn_cargs(
    t: str,
) -> None:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    vt = {
        "greedy": greedy_cargs,
        "input_images": greedy_input_images_cargs,
        "invert": greedy_invert_cargs,
        "root": greedy_root_cargs,
        "jacobian": greedy_jacobian_cargs,
        "metric": greedy_metric_cargs,
        "tjr": greedy_tjr_cargs,
        "search": greedy_search_cargs,
        "reslice_moving_image": greedy_reslice_moving_image_cargs,
        "reslice_surface": greedy_reslice_surface_cargs,
        "reslice_simplex_jacobian": greedy_reslice_simplex_jacobian_cargs,
    }
    return vt.get(t)


def dyn_outputs(
    t: str,
) -> None:
    """
    Get build outputs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build outputs function.
    """
    vt = {
        "greedy": greedy_outputs,
        "invert": greedy_invert_outputs,
        "root": greedy_root_outputs,
        "jacobian": greedy_jacobian_outputs,
        "reslice_moving_image": greedy_reslice_moving_image_outputs,
        "reslice_surface": greedy_reslice_surface_outputs,
        "reslice_simplex_jacobian": greedy_reslice_simplex_jacobian_outputs,
    }
    return vt.get(t)


def greedy_input_images_params(
    fixed: InputPathType,
    moving: InputPathType,
) -> GreedyInputImagesParameters:
    """
    Build parameters.
    
    Args:
        fixed: The fixed image.
        moving: The moving image.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "input_images",
        "fixed": fixed,
        "moving": moving,
    }
    return params


def greedy_input_images_cargs(
    params: GreedyInputImagesParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("fixed")))
    cargs.append(execution.input_file(params.get("moving")))
    return cargs


class GreedyInvertOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyInvertParameters | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    inverted_warp: OutputPathType
    """The inverted warp file"""


def greedy_invert_params(
    inwarp: InputPathType,
    outwarp: str,
) -> GreedyInvertParameters:
    """
    Build parameters.
    
    Args:
        inwarp: The input warp to be inverted.
        outwarp: The filename for the inverted warp output.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "invert",
        "inwarp": inwarp,
        "outwarp": outwarp,
    }
    return params


def greedy_invert_cargs(
    params: GreedyInvertParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("inwarp")))
    cargs.append(params.get("outwarp"))
    return cargs


def greedy_invert_outputs(
    params: GreedyInvertParameters,
    execution: Execution,
) -> GreedyInvertOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GreedyInvertOutputs(
        root=execution.output_file("."),
        inverted_warp=execution.output_file(params.get("outwarp")),
    )
    return ret


class GreedyRootOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyRootParameters | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    root_warp: OutputPathType
    """The 2^N-th root of the input warp"""


def greedy_root_params(
    inwarp: InputPathType,
    outwarp: str,
    n: int,
) -> GreedyRootParameters:
    """
    Build parameters.
    
    Args:
        inwarp: The input warp.
        outwarp: The filename for the root warp output.
        n: The value of N for 2^N-th root.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "root",
        "inwarp": inwarp,
        "outwarp": outwarp,
        "n": n,
    }
    return params


def greedy_root_cargs(
    params: GreedyRootParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("inwarp")))
    cargs.append(params.get("outwarp"))
    cargs.append(str(params.get("n")))
    return cargs


def greedy_root_outputs(
    params: GreedyRootParameters,
    execution: Execution,
) -> GreedyRootOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GreedyRootOutputs(
        root=execution.output_file("."),
        root_warp=execution.output_file(params.get("outwarp")),
    )
    return ret


class GreedyJacobianOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyJacobianParameters | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    jacobian_determinant: OutputPathType
    """The Jacobian determinant of the warp"""


def greedy_jacobian_params(
    inwarp: InputPathType,
    outjac: str,
) -> GreedyJacobianParameters:
    """
    Build parameters.
    
    Args:
        inwarp: The input warp.
        outjac: The filename for the Jacobian determinant output.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "jacobian",
        "inwarp": inwarp,
        "outjac": outjac,
    }
    return params


def greedy_jacobian_cargs(
    params: GreedyJacobianParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("inwarp")))
    cargs.append(params.get("outjac"))
    return cargs


def greedy_jacobian_outputs(
    params: GreedyJacobianParameters,
    execution: Execution,
) -> GreedyJacobianOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GreedyJacobianOutputs(
        root=execution.output_file("."),
        jacobian_determinant=execution.output_file(params.get("outjac")),
    )
    return ret


def greedy_metric_params(
    metric_type: typing.Literal["SSD", "MI", "NMI", "NCC", "MAHAL"],
    metric_param: float | None = None,
) -> GreedyMetricParameters:
    """
    Build parameters.
    
    Args:
        metric_type: Type of metric to use.
        metric_param: Parameter for the metric (e.g., radius for NCC).
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "metric",
        "metric_type": metric_type,
    }
    if metric_param is not None:
        params["metric_param"] = metric_param
    return params


def greedy_metric_cargs(
    params: GreedyMetricParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("metric_type"))
    if params.get("metric_param") is not None:
        cargs.append(str(params.get("metric_param")))
    return cargs


def greedy_tjr_params(
    mesh: InputPathType,
    weight: float,
) -> GreedyTjrParameters:
    """
    Build parameters.
    
    Args:
        mesh: The tetrahedral mesh file.
        weight: The weight of the penalty term.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "tjr",
        "mesh": mesh,
        "weight": weight,
    }
    return params


def greedy_tjr_cargs(
    params: GreedyTjrParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("mesh")))
    cargs.append(str(params.get("weight")))
    return cargs


def greedy_search_params(
    n: int,
    rot: str,
    tran: float,
) -> GreedySearchParameters:
    """
    Build parameters.
    
    Args:
        n: Number of iterations for random search.
        rot: Standard deviation of random rotation angle (degrees) or 'any' or\
            'flip'.
        tran: Standard deviation of random offset in physical units.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "search",
        "n": n,
        "rot": rot,
        "tran": tran,
    }
    return params


def greedy_search_cargs(
    params: GreedySearchParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(str(params.get("n")))
    cargs.append(params.get("rot"))
    cargs.append(str(params.get("tran")))
    return cargs


class GreedyResliceMovingImageOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyResliceMovingImageParameters | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    resliced_image: OutputPathType
    """The resliced output image"""


def greedy_reslice_moving_image_params(
    moving: InputPathType,
    output: str,
) -> GreedyResliceMovingImageParameters:
    """
    Build parameters.
    
    Args:
        moving: The moving image to be resliced.
        output: The filename for the resliced output image.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "reslice_moving_image",
        "moving": moving,
        "output": output,
    }
    return params


def greedy_reslice_moving_image_cargs(
    params: GreedyResliceMovingImageParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("moving")))
    cargs.append(params.get("output"))
    return cargs


def greedy_reslice_moving_image_outputs(
    params: GreedyResliceMovingImageParameters,
    execution: Execution,
) -> GreedyResliceMovingImageOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GreedyResliceMovingImageOutputs(
        root=execution.output_file("."),
        resliced_image=execution.output_file(params.get("output")),
    )
    return ret


class GreedyResliceSurfaceOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyResliceSurfaceParameters | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    warped_mesh: OutputPathType
    """The warped output mesh"""


def greedy_reslice_surface_params(
    inmesh: InputPathType,
    outmesh: str,
) -> GreedyResliceSurfaceParameters:
    """
    Build parameters.
    
    Args:
        inmesh: The input mesh file.
        outmesh: The filename for the output warped mesh.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "reslice_surface",
        "inmesh": inmesh,
        "outmesh": outmesh,
    }
    return params


def greedy_reslice_surface_cargs(
    params: GreedyResliceSurfaceParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("inmesh")))
    cargs.append(params.get("outmesh"))
    return cargs


def greedy_reslice_surface_outputs(
    params: GreedyResliceSurfaceParameters,
    execution: Execution,
) -> GreedyResliceSurfaceOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GreedyResliceSurfaceOutputs(
        root=execution.output_file("."),
        warped_mesh=execution.output_file(params.get("outmesh")),
    )
    return ret


class GreedyResliceSimplexJacobianOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyResliceSimplexJacobianParameters | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    jacobian_mesh: OutputPathType
    """The output mesh with computed Jacobian determinants"""


def greedy_reslice_simplex_jacobian_params(
    inmesh: InputPathType,
    outmesh: str,
) -> GreedyResliceSimplexJacobianParameters:
    """
    Build parameters.
    
    Args:
        inmesh: The input simplex mesh file.
        outmesh: The filename for the output mesh with Jacobian determinants.
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "reslice_simplex_jacobian",
        "inmesh": inmesh,
        "outmesh": outmesh,
    }
    return params


def greedy_reslice_simplex_jacobian_cargs(
    params: GreedyResliceSimplexJacobianParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("inmesh")))
    cargs.append(params.get("outmesh"))
    return cargs


def greedy_reslice_simplex_jacobian_outputs(
    params: GreedyResliceSimplexJacobianParameters,
    execution: Execution,
) -> GreedyResliceSimplexJacobianOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GreedyResliceSimplexJacobianOutputs(
        root=execution.output_file("."),
        jacobian_mesh=execution.output_file(params.get("outmesh")),
    )
    return ret


class GreedyOutputs(typing.NamedTuple):
    """
    Output object returned when calling `greedy_(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType | None
    """Output file from affine or deformable registration"""
    invert: GreedyInvertOutputs | None
    """Outputs from `greedy_invert_outputs`."""
    root_: GreedyRootOutputs | None
    """Outputs from `greedy_root_outputs`."""
    jacobian: GreedyJacobianOutputs | None
    """Outputs from `greedy_jacobian_outputs`."""
    reslice_moving_image: GreedyResliceMovingImageOutputs | None
    """Outputs from `greedy_reslice_moving_image_outputs`."""
    reslice_surface: GreedyResliceSurfaceOutputs | None
    """Outputs from `greedy_reslice_surface_outputs`."""
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianOutputs | None
    """Outputs from `greedy_reslice_simplex_jacobian_outputs`."""


def greedy_params(
    dimensions: int,
    input_images: GreedyInputImagesParameters | None = None,
    output: str | None = None,
    affine: bool = False,
    brute: str | None = None,
    moments: typing.Literal[1, 2] | None = None,
    reslice: list[InputPathType] | None = None,
    invert: GreedyInvertParameters | None = None,
    root: GreedyRootParameters | None = None,
    jacobian: GreedyJacobianParameters | None = None,
    metric_mode: bool = False,
    defopt: bool = False,
    weight: float | None = None,
    metric: GreedyMetricParameters | None = None,
    step_size: str | None = None,
    iterations: str | None = None,
    threads: int | None = None,
    fixed_mask: InputPathType | None = None,
    gm_trim: float | None = None,
    moving_mask: InputPathType | None = None,
    wncc_mask_dilate: bool = False,
    reference_image: InputPathType | None = None,
    ref_pad: float | None = None,
    background: str | None = None,
    input_transform: InputPathType | None = None,
    zero_last_dimension: bool = False,
    time_step_mode: typing.Literal["CONST", "SCALE", "SCALEDOWN"] | None = None,
    smoothing: str | None = None,
    inverse_warp: InputPathType | None = None,
    root_warp: InputPathType | None = None,
    warp_precision: float | None = None,
    noise: float | None = None,
    exponent: float | None = None,
    svf_mode: bool = False,
    svlb: bool = False,
    sv_incompr: bool = False,
    initial_warp: InputPathType | None = None,
    tjr: GreedyTjrParameters | None = None,
    wr: float | None = None,
    initial_affine: InputPathType | None = None,
    ia_identity: bool = False,
    ia_voxel_grid: bool = False,
    ia_image_centers: bool = False,
    ia_image_side: str | None = None,
    ia_moments: typing.Literal[1, 2] | None = None,
    affine_dof: typing.Literal[6, 7, 12] | None = None,
    jitter: float | None = None,
    search: GreedySearchParameters | None = None,
    det: typing.Literal[-1, 1] | None = None,
    cov_id: bool = False,
    fixed_reslicing_image: InputPathType | None = None,
    reslice_moving_image: GreedyResliceMovingImageParameters | None = None,
    reslice_surface: GreedyResliceSurfaceParameters | None = None,
    interpolation: typing.Literal["NN", "LINEAR", "LABEL"] | None = None,
    reslice_background: float | None = None,
    reslice_datatype: typing.Literal["auto", "double", "float", "uint", "int", "ushort", "short", "uchar", "char"] | None = None,
    reslice_composite: InputPathType | None = None,
    reslice_jacobian: InputPathType | None = None,
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianParameters | None = None,
    reslice_mask: InputPathType | None = None,
    metric_gradient: InputPathType | None = None,
    debug_deriv: bool = False,
    debug_deriv_eps: float | None = None,
    debug_aff_obj: bool = False,
    dump_pyramid: bool = False,
    dump_moving: bool = False,
    dump_frequency: float | None = None,
    dump_prefix: str | None = None,
    powell: bool = False,
    float_: bool = False,
    version: bool = False,
    verbosity: typing.Literal[0, 1, 2] | None = None,
) -> GreedyParameters:
    """
    Build parameters.
    
    Args:
        dimensions: Number of image dimensions.
        input_images: Image pair (may be repeated).
        output: Output file (matrix in affine mode; image in deformable mode,\
            metric computation mode; ignored in reslicing mode).
        affine: Perform affine registration and save to output (-o).
        brute: Perform a brute force search around each voxel.
        moments: Perform moments of inertia rigid alignment of given order (1\
            or 2).
        reslice: Reslice images instead of doing registration.
        invert: Invert previously computed warp.
        root: Convert 2^N-th root of a warp.
        jacobian: Compute the Jacobian determinant of the warp.
        metric_mode: Compute metric between images.
        defopt: Deformable optimization mode (experimental).
        weight: Weight of the next -i pair.
        metric: Metric for the entire registration.
        step_size: Step size for optimization (default = 1.0), may also be\
            specified per level (e.g. 0.3x0.1).
        iterations: Number of iterations per level of multi-res.
        threads: Number of allowed concurrent threads.
        fixed_mask: Fixed image mask (metric gradients computed only over the\
            mask).
        gm_trim: Generate the fixed image mask by trimming the extent of the\
            fixed image by given radius.
        moving_mask: Moving image mask (pixels outside are excluded from metric\
            computation).
        wncc_mask_dilate: Specifies that fixed and moving masks should be\
            dilated by the radius of the WNCC metric during registration.
        reference_image: Use supplied image, rather than fixed image to define\
            the reference space.
        ref_pad: Define the reference space by padding the fixed image by\
            radius.
        background: Value to fill missing values when mapping fixed and moving\
            images to reference space.
        input_transform: Specify transforms (matrices, warps) that map moving\
            image to reference space.
        zero_last_dimension: Sets sigmas and NCC radius to zero in the last\
            dimension for 2D/3D registration.
        time_step_mode: Time step behavior mode.
        smoothing: Smoothing for the greedy update step (e.g., '1.732vox\
            0.7071vox').
        inverse_warp: Compute and write the inverse of the warp field.
        root_warp: Compute and write the (2^N-th) root of the warp field.
        warp_precision: Saved warp precision in voxels (default=0.1; 0 for no\
            compression).
        noise: Standard deviation of white noise added to moving/fixed images\
            when using NCC metric.
        exponent: The exponent used for warp inversion, root computation, and\
            in stationary velocity field mode.
        svf_mode: Perform registration using the stationary velocity model.
        svlb: Use more accurate but expensive update of v in stationary\
            velocity field mode.
        sv_incompr: Incompressibility mode, implements Mansi et al. 2011\
            iLogDemons.
        initial_warp: Specifies the initial warp to start iteration from.
        tjr: Apply a regularization penalty based on the Jacobian of a\
            tetrahedral mesh.
        wr: Weight of SVF smoothness regularization term (default: 1000).
        initial_affine: Initial affine matrix for optimization.
        ia_identity: Initialize affine matrix based on NIFTI headers.
        ia_voxel_grid: Initialize affine matrix so that voxels with\
            corresponding indices align.
        ia_image_centers: Initialize affine matrix based on matching image\
            centers.
        ia_image_side: Initialize affine matrix based on matching center of one\
            image side.
        ia_moments: Initialize affine matrix based on matching moments of\
            inertia.
        affine_dof: Degrees of freedom for affine registration. 6=rigid,\
            7=similarity, 12=affine.
        jitter: Jitter (in voxel units) applied to sample points (default: 0.5).
        search: Random search over rigid transforms before starting\
            optimization.
        det: Force the determinant of transform to be either 1 (no flip) or -1\
            (flip).
        cov_id: Assume identity covariance (match centers and do flips only, no\
            rotation).
        fixed_reslicing_image: Fixed image for reslicing.
        reslice_moving_image: Moving/output image pair for reslicing.
        reslice_surface: Fixed/output surface pair (vertices are warped from\
            fixed space to moving).
        interpolation: Interpolation for the next pair (NN, LINEAR*, LABEL\
            sigma).
        reslice_background: Background (i.e. outside) intensity for the next\
            pair (default 0).
        reslice_datatype: Data type for the next pair.
        reslice_composite: Write composed transforms to outwarp.
        reslice_jacobian: Write Jacobian determinant image to outjacobian.
        reslice_simplex_jacobian: Compute Jacobian determinant for a simplex\
            mesh in fixed space.
        reslice_mask: A binary mask for the fixed image; zero values will be\
            overwritten with background.
        metric_gradient: Write the gradient of the metric to file.
        debug_deriv: Enable periodic checks of derivatives (debug).
        debug_deriv_eps: Epsilon for derivative debugging.
        debug_aff_obj: Plot affine objective in neighborhood of -ia matrix.
        dump_pyramid: Dump the image pyramid at the start of the registration.
        dump_moving: Dump moving image at each iter.
        dump_frequency: Dump frequency.
        dump_prefix: Prefix for dump files (may be a path).
        powell: Use Powell's method instead of LGBFS.
        float_: Use single precision floating point (off by default).
        version: Print version info.
        verbosity: Verbosity level (0: none, 1: default, 2: verbose).
    Returns:
        Parameter dictionary
    """
    params = {
        "__STYXTYPE__": "greedy",
        "dimensions": dimensions,
        "affine": affine,
        "metric_mode": metric_mode,
        "defopt": defopt,
        "wncc_mask_dilate": wncc_mask_dilate,
        "zero_last_dimension": zero_last_dimension,
        "svf_mode": svf_mode,
        "svlb": svlb,
        "sv_incompr": sv_incompr,
        "ia_identity": ia_identity,
        "ia_voxel_grid": ia_voxel_grid,
        "ia_image_centers": ia_image_centers,
        "cov_id": cov_id,
        "debug_deriv": debug_deriv,
        "debug_aff_obj": debug_aff_obj,
        "dump_pyramid": dump_pyramid,
        "dump_moving": dump_moving,
        "powell": powell,
        "float": float_,
        "version": version,
    }
    if input_images is not None:
        params["input_images"] = input_images
    if output is not None:
        params["output"] = output
    if brute is not None:
        params["brute"] = brute
    if moments is not None:
        params["moments"] = moments
    if reslice is not None:
        params["reslice"] = reslice
    if invert is not None:
        params["invert"] = invert
    if root is not None:
        params["root"] = root
    if jacobian is not None:
        params["jacobian"] = jacobian
    if weight is not None:
        params["weight"] = weight
    if metric is not None:
        params["metric"] = metric
    if step_size is not None:
        params["step_size"] = step_size
    if iterations is not None:
        params["iterations"] = iterations
    if threads is not None:
        params["threads"] = threads
    if fixed_mask is not None:
        params["fixed_mask"] = fixed_mask
    if gm_trim is not None:
        params["gm_trim"] = gm_trim
    if moving_mask is not None:
        params["moving_mask"] = moving_mask
    if reference_image is not None:
        params["reference_image"] = reference_image
    if ref_pad is not None:
        params["ref_pad"] = ref_pad
    if background is not None:
        params["background"] = background
    if input_transform is not None:
        params["input_transform"] = input_transform
    if time_step_mode is not None:
        params["time_step_mode"] = time_step_mode
    if smoothing is not None:
        params["smoothing"] = smoothing
    if inverse_warp is not None:
        params["inverse_warp"] = inverse_warp
    if root_warp is not None:
        params["root_warp"] = root_warp
    if warp_precision is not None:
        params["warp_precision"] = warp_precision
    if noise is not None:
        params["noise"] = noise
    if exponent is not None:
        params["exponent"] = exponent
    if initial_warp is not None:
        params["initial_warp"] = initial_warp
    if tjr is not None:
        params["tjr"] = tjr
    if wr is not None:
        params["wr"] = wr
    if initial_affine is not None:
        params["initial_affine"] = initial_affine
    if ia_image_side is not None:
        params["ia_image_side"] = ia_image_side
    if ia_moments is not None:
        params["ia_moments"] = ia_moments
    if affine_dof is not None:
        params["affine_dof"] = affine_dof
    if jitter is not None:
        params["jitter"] = jitter
    if search is not None:
        params["search"] = search
    if det is not None:
        params["det"] = det
    if fixed_reslicing_image is not None:
        params["fixed_reslicing_image"] = fixed_reslicing_image
    if reslice_moving_image is not None:
        params["reslice_moving_image"] = reslice_moving_image
    if reslice_surface is not None:
        params["reslice_surface"] = reslice_surface
    if interpolation is not None:
        params["interpolation"] = interpolation
    if reslice_background is not None:
        params["reslice_background"] = reslice_background
    if reslice_datatype is not None:
        params["reslice_datatype"] = reslice_datatype
    if reslice_composite is not None:
        params["reslice_composite"] = reslice_composite
    if reslice_jacobian is not None:
        params["reslice_jacobian"] = reslice_jacobian
    if reslice_simplex_jacobian is not None:
        params["reslice_simplex_jacobian"] = reslice_simplex_jacobian
    if reslice_mask is not None:
        params["reslice_mask"] = reslice_mask
    if metric_gradient is not None:
        params["metric_gradient"] = metric_gradient
    if debug_deriv_eps is not None:
        params["debug_deriv_eps"] = debug_deriv_eps
    if dump_frequency is not None:
        params["dump_frequency"] = dump_frequency
    if dump_prefix is not None:
        params["dump_prefix"] = dump_prefix
    if verbosity is not None:
        params["verbosity"] = verbosity
    return params


def greedy_cargs(
    params: GreedyParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("greedy")
    cargs.extend([
        "-d",
        str(params.get("dimensions"))
    ])
    if params.get("input_images") is not None:
        cargs.extend([
            "-i",
            *dyn_cargs(params.get("input_images")["__STYXTYPE__"])(params.get("input_images"), execution)
        ])
    if params.get("output") is not None:
        cargs.extend([
            "-o",
            params.get("output")
        ])
    if params.get("affine"):
        cargs.append("-a")
    if params.get("brute") is not None:
        cargs.extend([
            "-brute",
            params.get("brute")
        ])
    if params.get("moments") is not None:
        cargs.extend([
            "-moments",
            str(params.get("moments"))
        ])
    if params.get("reslice") is not None:
        cargs.extend([
            "-r",
            *[execution.input_file(f) for f in params.get("reslice")]
        ])
    if params.get("invert") is not None:
        cargs.extend([
            "-iw",
            *dyn_cargs(params.get("invert")["__STYXTYPE__"])(params.get("invert"), execution)
        ])
    if params.get("root") is not None:
        cargs.extend([
            "-root",
            *dyn_cargs(params.get("root")["__STYXTYPE__"])(params.get("root"), execution)
        ])
    if params.get("jacobian") is not None:
        cargs.extend([
            "-jac",
            *dyn_cargs(params.get("jacobian")["__STYXTYPE__"])(params.get("jacobian"), execution)
        ])
    if params.get("metric_mode"):
        cargs.append("-metric")
    if params.get("defopt"):
        cargs.append("-defopt")
    if params.get("weight") is not None:
        cargs.extend([
            "-w",
            str(params.get("weight"))
        ])
    if params.get("metric") is not None:
        cargs.extend([
            "-m",
            *dyn_cargs(params.get("metric")["__STYXTYPE__"])(params.get("metric"), execution)
        ])
    if params.get("step_size") is not None:
        cargs.extend([
            "-e",
            params.get("step_size")
        ])
    if params.get("iterations") is not None:
        cargs.extend([
            "-n",
            params.get("iterations")
        ])
    if params.get("threads") is not None:
        cargs.extend([
            "-threads",
            str(params.get("threads"))
        ])
    if params.get("fixed_mask") is not None:
        cargs.extend([
            "-gm",
            execution.input_file(params.get("fixed_mask"))
        ])
    if params.get("gm_trim") is not None:
        cargs.extend([
            "-gm-trim",
            str(params.get("gm_trim"))
        ])
    if params.get("moving_mask") is not None:
        cargs.extend([
            "-mm",
            execution.input_file(params.get("moving_mask"))
        ])
    if params.get("wncc_mask_dilate"):
        cargs.append("-wncc-mask-dilate")
    if params.get("reference_image") is not None:
        cargs.extend([
            "-ref",
            execution.input_file(params.get("reference_image"))
        ])
    if params.get("ref_pad") is not None:
        cargs.extend([
            "-ref-pad",
            str(params.get("ref_pad"))
        ])
    if params.get("background") is not None:
        cargs.extend([
            "-bg",
            params.get("background")
        ])
    if params.get("input_transform") is not None:
        cargs.extend([
            "-it",
            execution.input_file(params.get("input_transform"))
        ])
    if params.get("zero_last_dimension"):
        cargs.append("-z")
    if params.get("time_step_mode") is not None:
        cargs.extend([
            "-tscale",
            params.get("time_step_mode")
        ])
    if params.get("smoothing") is not None:
        cargs.extend([
            "-s",
            params.get("smoothing")
        ])
    if params.get("inverse_warp") is not None:
        cargs.extend([
            "-oinv",
            execution.input_file(params.get("inverse_warp"))
        ])
    if params.get("root_warp") is not None:
        cargs.extend([
            "-oroot",
            execution.input_file(params.get("root_warp"))
        ])
    if params.get("warp_precision") is not None:
        cargs.extend([
            "-wp",
            str(params.get("warp_precision"))
        ])
    if params.get("noise") is not None:
        cargs.extend([
            "-noise",
            str(params.get("noise"))
        ])
    if params.get("exponent") is not None:
        cargs.extend([
            "-exp",
            str(params.get("exponent"))
        ])
    if params.get("svf_mode"):
        cargs.append("-sv")
    if params.get("svlb"):
        cargs.append("-svlb")
    if params.get("sv_incompr"):
        cargs.append("-sv-incompr")
    if params.get("initial_warp") is not None:
        cargs.extend([
            "-id",
            execution.input_file(params.get("initial_warp"))
        ])
    if params.get("tjr") is not None:
        cargs.extend([
            "-tjr",
            *dyn_cargs(params.get("tjr")["__STYXTYPE__"])(params.get("tjr"), execution)
        ])
    if params.get("wr") is not None:
        cargs.extend([
            "-wr",
            str(params.get("wr"))
        ])
    if params.get("initial_affine") is not None:
        cargs.extend([
            "-ia",
            execution.input_file(params.get("initial_affine"))
        ])
    if params.get("ia_identity"):
        cargs.append("-ia-identity")
    if params.get("ia_voxel_grid"):
        cargs.append("-ia-voxel-grid")
    if params.get("ia_image_centers"):
        cargs.append("-ia-image-centers")
    if params.get("ia_image_side") is not None:
        cargs.extend([
            "-ia-image-side",
            params.get("ia_image_side")
        ])
    if params.get("ia_moments") is not None:
        cargs.extend([
            "-ia-moments",
            str(params.get("ia_moments"))
        ])
    if params.get("affine_dof") is not None:
        cargs.extend([
            "-dof",
            str(params.get("affine_dof"))
        ])
    if params.get("jitter") is not None:
        cargs.extend([
            "-jitter",
            str(params.get("jitter"))
        ])
    if params.get("search") is not None:
        cargs.extend([
            "-search",
            *dyn_cargs(params.get("search")["__STYXTYPE__"])(params.get("search"), execution)
        ])
    if params.get("det") is not None:
        cargs.extend([
            "-det",
            str(params.get("det"))
        ])
    if params.get("cov_id"):
        cargs.append("-cov-id")
    if params.get("fixed_reslicing_image") is not None:
        cargs.extend([
            "-rf",
            execution.input_file(params.get("fixed_reslicing_image"))
        ])
    if params.get("reslice_moving_image") is not None:
        cargs.extend([
            "-rm",
            *dyn_cargs(params.get("reslice_moving_image")["__STYXTYPE__"])(params.get("reslice_moving_image"), execution)
        ])
    if params.get("reslice_surface") is not None:
        cargs.extend([
            "-rs",
            *dyn_cargs(params.get("reslice_surface")["__STYXTYPE__"])(params.get("reslice_surface"), execution)
        ])
    if params.get("interpolation") is not None:
        cargs.extend([
            "-ri",
            params.get("interpolation")
        ])
    if params.get("reslice_background") is not None:
        cargs.extend([
            "-rb",
            str(params.get("reslice_background"))
        ])
    if params.get("reslice_datatype") is not None:
        cargs.extend([
            "-rt",
            params.get("reslice_datatype")
        ])
    if params.get("reslice_composite") is not None:
        cargs.extend([
            "-rc",
            execution.input_file(params.get("reslice_composite"))
        ])
    if params.get("reslice_jacobian") is not None:
        cargs.extend([
            "-rj",
            execution.input_file(params.get("reslice_jacobian"))
        ])
    if params.get("reslice_simplex_jacobian") is not None:
        cargs.extend([
            "-rsj",
            *dyn_cargs(params.get("reslice_simplex_jacobian")["__STYXTYPE__"])(params.get("reslice_simplex_jacobian"), execution)
        ])
    if params.get("reslice_mask") is not None:
        cargs.extend([
            "-rk",
            execution.input_file(params.get("reslice_mask"))
        ])
    if params.get("metric_gradient") is not None:
        cargs.extend([
            "-og",
            execution.input_file(params.get("metric_gradient"))
        ])
    if params.get("debug_deriv"):
        cargs.append("-debug-deriv")
    if params.get("debug_deriv_eps") is not None:
        cargs.extend([
            "-debug-deriv-eps",
            str(params.get("debug_deriv_eps"))
        ])
    if params.get("debug_aff_obj"):
        cargs.append("-debug-aff-obj")
    if params.get("dump_pyramid"):
        cargs.append("-dump-pyramid")
    if params.get("dump_moving"):
        cargs.append("-dump-moving")
    if params.get("dump_frequency") is not None:
        cargs.extend([
            "-dump-freq",
            str(params.get("dump_frequency"))
        ])
    if params.get("dump_prefix") is not None:
        cargs.extend([
            "-dump-prefix",
            params.get("dump_prefix")
        ])
    if params.get("powell"):
        cargs.append("-powell")
    if params.get("float"):
        cargs.append("-float")
    if params.get("version"):
        cargs.append("-version")
    if params.get("verbosity") is not None:
        cargs.extend([
            "-V",
            str(params.get("verbosity"))
        ])
    return cargs


def greedy_outputs(
    params: GreedyParameters,
    execution: Execution,
) -> GreedyOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GreedyOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(params.get("output")) if (params.get("output") is not None) else None,
        invert=dyn_outputs(invert["__STYXTYPE__"])(invert, execution) if invert else None,
        root_=dyn_outputs(root["__STYXTYPE__"])(root, execution) if root else None,
        jacobian=dyn_outputs(jacobian["__STYXTYPE__"])(jacobian, execution) if jacobian else None,
        reslice_moving_image=dyn_outputs(reslice_moving_image["__STYXTYPE__"])(reslice_moving_image, execution) if reslice_moving_image else None,
        reslice_surface=dyn_outputs(reslice_surface["__STYXTYPE__"])(reslice_surface, execution) if reslice_surface else None,
        reslice_simplex_jacobian=dyn_outputs(reslice_simplex_jacobian["__STYXTYPE__"])(reslice_simplex_jacobian, execution) if reslice_simplex_jacobian else None,
    )
    return ret


def greedy_execute(
    params: GreedyParameters,
    execution: Execution,
) -> GreedyOutputs:
    """
    Paul's greedy diffeomorphic registration implementation.
    
    Author: Greedy Developers
    
    URL: https://sites.google.com/view/greedyreg/about
    
    Args:
        params: The parameters.
        execution: The execution object.
    Returns:
        NamedTuple of outputs (described in `GreedyOutputs`).
    """
    # validate constraint checks (or after middlewares?)
    cargs = greedy_cargs(params, execution)
    ret = greedy_outputs(params, execution)
    execution.run(cargs)
    return ret


def greedy_(
    dimensions: int,
    input_images: GreedyInputImagesParameters | None = None,
    output: str | None = None,
    affine: bool = False,
    brute: str | None = None,
    moments: typing.Literal[1, 2] | None = None,
    reslice: list[InputPathType] | None = None,
    invert: GreedyInvertParameters | None = None,
    root: GreedyRootParameters | None = None,
    jacobian: GreedyJacobianParameters | None = None,
    metric_mode: bool = False,
    defopt: bool = False,
    weight: float | None = None,
    metric: GreedyMetricParameters | None = None,
    step_size: str | None = None,
    iterations: str | None = None,
    threads: int | None = None,
    fixed_mask: InputPathType | None = None,
    gm_trim: float | None = None,
    moving_mask: InputPathType | None = None,
    wncc_mask_dilate: bool = False,
    reference_image: InputPathType | None = None,
    ref_pad: float | None = None,
    background: str | None = None,
    input_transform: InputPathType | None = None,
    zero_last_dimension: bool = False,
    time_step_mode: typing.Literal["CONST", "SCALE", "SCALEDOWN"] | None = None,
    smoothing: str | None = None,
    inverse_warp: InputPathType | None = None,
    root_warp: InputPathType | None = None,
    warp_precision: float | None = None,
    noise: float | None = None,
    exponent: float | None = None,
    svf_mode: bool = False,
    svlb: bool = False,
    sv_incompr: bool = False,
    initial_warp: InputPathType | None = None,
    tjr: GreedyTjrParameters | None = None,
    wr: float | None = None,
    initial_affine: InputPathType | None = None,
    ia_identity: bool = False,
    ia_voxel_grid: bool = False,
    ia_image_centers: bool = False,
    ia_image_side: str | None = None,
    ia_moments: typing.Literal[1, 2] | None = None,
    affine_dof: typing.Literal[6, 7, 12] | None = None,
    jitter: float | None = None,
    search: GreedySearchParameters | None = None,
    det: typing.Literal[-1, 1] | None = None,
    cov_id: bool = False,
    fixed_reslicing_image: InputPathType | None = None,
    reslice_moving_image: GreedyResliceMovingImageParameters | None = None,
    reslice_surface: GreedyResliceSurfaceParameters | None = None,
    interpolation: typing.Literal["NN", "LINEAR", "LABEL"] | None = None,
    reslice_background: float | None = None,
    reslice_datatype: typing.Literal["auto", "double", "float", "uint", "int", "ushort", "short", "uchar", "char"] | None = None,
    reslice_composite: InputPathType | None = None,
    reslice_jacobian: InputPathType | None = None,
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianParameters | None = None,
    reslice_mask: InputPathType | None = None,
    metric_gradient: InputPathType | None = None,
    debug_deriv: bool = False,
    debug_deriv_eps: float | None = None,
    debug_aff_obj: bool = False,
    dump_pyramid: bool = False,
    dump_moving: bool = False,
    dump_frequency: float | None = None,
    dump_prefix: str | None = None,
    powell: bool = False,
    float_: bool = False,
    version: bool = False,
    verbosity: typing.Literal[0, 1, 2] | None = None,
    runner: Runner | None = None,
) -> GreedyOutputs:
    """
    Paul's greedy diffeomorphic registration implementation.
    
    Author: Greedy Developers
    
    URL: https://sites.google.com/view/greedyreg/about
    
    Args:
        dimensions: Number of image dimensions.
        input_images: Image pair (may be repeated).
        output: Output file (matrix in affine mode; image in deformable mode,\
            metric computation mode; ignored in reslicing mode).
        affine: Perform affine registration and save to output (-o).
        brute: Perform a brute force search around each voxel.
        moments: Perform moments of inertia rigid alignment of given order (1\
            or 2).
        reslice: Reslice images instead of doing registration.
        invert: Invert previously computed warp.
        root: Convert 2^N-th root of a warp.
        jacobian: Compute the Jacobian determinant of the warp.
        metric_mode: Compute metric between images.
        defopt: Deformable optimization mode (experimental).
        weight: Weight of the next -i pair.
        metric: Metric for the entire registration.
        step_size: Step size for optimization (default = 1.0), may also be\
            specified per level (e.g. 0.3x0.1).
        iterations: Number of iterations per level of multi-res.
        threads: Number of allowed concurrent threads.
        fixed_mask: Fixed image mask (metric gradients computed only over the\
            mask).
        gm_trim: Generate the fixed image mask by trimming the extent of the\
            fixed image by given radius.
        moving_mask: Moving image mask (pixels outside are excluded from metric\
            computation).
        wncc_mask_dilate: Specifies that fixed and moving masks should be\
            dilated by the radius of the WNCC metric during registration.
        reference_image: Use supplied image, rather than fixed image to define\
            the reference space.
        ref_pad: Define the reference space by padding the fixed image by\
            radius.
        background: Value to fill missing values when mapping fixed and moving\
            images to reference space.
        input_transform: Specify transforms (matrices, warps) that map moving\
            image to reference space.
        zero_last_dimension: Sets sigmas and NCC radius to zero in the last\
            dimension for 2D/3D registration.
        time_step_mode: Time step behavior mode.
        smoothing: Smoothing for the greedy update step (e.g., '1.732vox\
            0.7071vox').
        inverse_warp: Compute and write the inverse of the warp field.
        root_warp: Compute and write the (2^N-th) root of the warp field.
        warp_precision: Saved warp precision in voxels (default=0.1; 0 for no\
            compression).
        noise: Standard deviation of white noise added to moving/fixed images\
            when using NCC metric.
        exponent: The exponent used for warp inversion, root computation, and\
            in stationary velocity field mode.
        svf_mode: Perform registration using the stationary velocity model.
        svlb: Use more accurate but expensive update of v in stationary\
            velocity field mode.
        sv_incompr: Incompressibility mode, implements Mansi et al. 2011\
            iLogDemons.
        initial_warp: Specifies the initial warp to start iteration from.
        tjr: Apply a regularization penalty based on the Jacobian of a\
            tetrahedral mesh.
        wr: Weight of SVF smoothness regularization term (default: 1000).
        initial_affine: Initial affine matrix for optimization.
        ia_identity: Initialize affine matrix based on NIFTI headers.
        ia_voxel_grid: Initialize affine matrix so that voxels with\
            corresponding indices align.
        ia_image_centers: Initialize affine matrix based on matching image\
            centers.
        ia_image_side: Initialize affine matrix based on matching center of one\
            image side.
        ia_moments: Initialize affine matrix based on matching moments of\
            inertia.
        affine_dof: Degrees of freedom for affine registration. 6=rigid,\
            7=similarity, 12=affine.
        jitter: Jitter (in voxel units) applied to sample points (default: 0.5).
        search: Random search over rigid transforms before starting\
            optimization.
        det: Force the determinant of transform to be either 1 (no flip) or -1\
            (flip).
        cov_id: Assume identity covariance (match centers and do flips only, no\
            rotation).
        fixed_reslicing_image: Fixed image for reslicing.
        reslice_moving_image: Moving/output image pair for reslicing.
        reslice_surface: Fixed/output surface pair (vertices are warped from\
            fixed space to moving).
        interpolation: Interpolation for the next pair (NN, LINEAR*, LABEL\
            sigma).
        reslice_background: Background (i.e. outside) intensity for the next\
            pair (default 0).
        reslice_datatype: Data type for the next pair.
        reslice_composite: Write composed transforms to outwarp.
        reslice_jacobian: Write Jacobian determinant image to outjacobian.
        reslice_simplex_jacobian: Compute Jacobian determinant for a simplex\
            mesh in fixed space.
        reslice_mask: A binary mask for the fixed image; zero values will be\
            overwritten with background.
        metric_gradient: Write the gradient of the metric to file.
        debug_deriv: Enable periodic checks of derivatives (debug).
        debug_deriv_eps: Epsilon for derivative debugging.
        debug_aff_obj: Plot affine objective in neighborhood of -ia matrix.
        dump_pyramid: Dump the image pyramid at the start of the registration.
        dump_moving: Dump moving image at each iter.
        dump_frequency: Dump frequency.
        dump_prefix: Prefix for dump files (may be a path).
        powell: Use Powell's method instead of LGBFS.
        float_: Use single precision floating point (off by default).
        version: Print version info.
        verbosity: Verbosity level (0: none, 1: default, 2: verbose).
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `GreedyOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(GREEDY_METADATA)
    params = greedy_params(dimensions=dimensions, input_images=input_images, output=output, affine=affine, brute=brute, moments=moments, reslice=reslice, invert=invert, root=root, jacobian=jacobian, metric_mode=metric_mode, defopt=defopt, weight=weight, metric=metric, step_size=step_size, iterations=iterations, threads=threads, fixed_mask=fixed_mask, gm_trim=gm_trim, moving_mask=moving_mask, wncc_mask_dilate=wncc_mask_dilate, reference_image=reference_image, ref_pad=ref_pad, background=background, input_transform=input_transform, zero_last_dimension=zero_last_dimension, time_step_mode=time_step_mode, smoothing=smoothing, inverse_warp=inverse_warp, root_warp=root_warp, warp_precision=warp_precision, noise=noise, exponent=exponent, svf_mode=svf_mode, svlb=svlb, sv_incompr=sv_incompr, initial_warp=initial_warp, tjr=tjr, wr=wr, initial_affine=initial_affine, ia_identity=ia_identity, ia_voxel_grid=ia_voxel_grid, ia_image_centers=ia_image_centers, ia_image_side=ia_image_side, ia_moments=ia_moments, affine_dof=affine_dof, jitter=jitter, search=search, det=det, cov_id=cov_id, fixed_reslicing_image=fixed_reslicing_image, reslice_moving_image=reslice_moving_image, reslice_surface=reslice_surface, interpolation=interpolation, reslice_background=reslice_background, reslice_datatype=reslice_datatype, reslice_composite=reslice_composite, reslice_jacobian=reslice_jacobian, reslice_simplex_jacobian=reslice_simplex_jacobian, reslice_mask=reslice_mask, metric_gradient=metric_gradient, debug_deriv=debug_deriv, debug_deriv_eps=debug_deriv_eps, debug_aff_obj=debug_aff_obj, dump_pyramid=dump_pyramid, dump_moving=dump_moving, dump_frequency=dump_frequency, dump_prefix=dump_prefix, powell=powell, float_=float_, version=version, verbosity=verbosity)
    return greedy_execute(params, execution)


__all__ = [
    "GREEDY_METADATA",
    "GreedyInvertOutputs",
    "GreedyJacobianOutputs",
    "GreedyOutputs",
    "GreedyResliceMovingImageOutputs",
    "GreedyResliceSimplexJacobianOutputs",
    "GreedyResliceSurfaceOutputs",
    "GreedyRootOutputs",
    "greedy_",
    "greedy_input_images_params",
    "greedy_invert_params",
    "greedy_jacobian_params",
    "greedy_metric_params",
    "greedy_params",
    "greedy_reslice_moving_image_params",
    "greedy_reslice_simplex_jacobian_params",
    "greedy_reslice_surface_params",
    "greedy_root_params",
    "greedy_search_params",
    "greedy_tjr_params",
]
