# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *
import dataclasses

GREEDY_METADATA = Metadata(
    id="81e25c6c4fb84453185826b4258b91dafaf56f30.boutiques",
    name="greedy",
    package="greedy",
    container_image_tag="pyushkevich/itksnap:v3.8.2",
)


@dataclasses.dataclass
class GreedyInputImages:
    """
    Image pair (may be repeated).
    """
    fixed: InputPathType
    """The fixed image"""
    moving: InputPathType
    """The moving image"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.fixed))
        cargs.append(execution.input_file(self.moving))
        return cargs


class GreedyInvertOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyInvert | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    inverted_warp: OutputPathType
    """The inverted warp file"""


@dataclasses.dataclass
class GreedyInvert:
    """
    Invert previously computed warp.
    """
    inwarp: InputPathType
    """The input warp to be inverted"""
    outwarp: str
    """The filename for the inverted warp output"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.inwarp))
        cargs.append(self.outwarp)
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> GreedyInvertOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `GreedyInvertOutputs`).
        """
        ret = GreedyInvertOutputs(
            root=execution.output_file("."),
            inverted_warp=execution.output_file(self.outwarp),
        )
        return ret


class GreedyRootOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyRoot | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    root_warp: OutputPathType
    """The 2^N-th root of the input warp"""


@dataclasses.dataclass
class GreedyRoot:
    """
    Convert 2^N-th root of a warp.
    """
    inwarp: InputPathType
    """The input warp"""
    outwarp: str
    """The filename for the root warp output"""
    n: int
    """The value of N for 2^N-th root"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.inwarp))
        cargs.append(self.outwarp)
        cargs.append(str(self.n))
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> GreedyRootOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `GreedyRootOutputs`).
        """
        ret = GreedyRootOutputs(
            root=execution.output_file("."),
            root_warp=execution.output_file(self.outwarp),
        )
        return ret


class GreedyJacobianOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyJacobian | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    jacobian_determinant: OutputPathType
    """The Jacobian determinant of the warp"""


@dataclasses.dataclass
class GreedyJacobian:
    """
    Compute the Jacobian determinant of the warp.
    """
    inwarp: InputPathType
    """The input warp"""
    outjac: str
    """The filename for the Jacobian determinant output"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.inwarp))
        cargs.append(self.outjac)
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> GreedyJacobianOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `GreedyJacobianOutputs`).
        """
        ret = GreedyJacobianOutputs(
            root=execution.output_file("."),
            jacobian_determinant=execution.output_file(self.outjac),
        )
        return ret


@dataclasses.dataclass
class GreedyMetric:
    """
    Metric for the entire registration.
    """
    metric_type: typing.Literal["SSD", "MI", "NMI", "NCC", "MAHAL"]
    """Type of metric to use"""
    metric_param: float | None = None
    """Parameter for the metric (e.g., radius for NCC)"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(self.metric_type)
        if self.metric_param is not None:
            cargs.append(str(self.metric_param))
        return cargs


@dataclasses.dataclass
class GreedyTjr:
    """
    Apply a regularization penalty based on the Jacobian of a tetrahedral mesh.
    """
    mesh: InputPathType
    """The tetrahedral mesh file"""
    weight: float
    """The weight of the penalty term"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.mesh))
        cargs.append(str(self.weight))
        return cargs


@dataclasses.dataclass
class GreedySearch:
    """
    Random search over rigid transforms before starting optimization.
    """
    n: int
    """Number of iterations for random search"""
    rot: str
    """Standard deviation of random rotation angle (degrees) or 'any' or
    'flip'"""
    tran: float
    """Standard deviation of random offset in physical units"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(str(self.n))
        cargs.append(self.rot)
        cargs.append(str(self.tran))
        return cargs


class GreedyResliceMovingImageOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyResliceMovingImage | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    resliced_image: OutputPathType
    """The resliced output image"""


@dataclasses.dataclass
class GreedyResliceMovingImage:
    """
    Moving/output image pair for reslicing.
    """
    moving: InputPathType
    """The moving image to be resliced"""
    output: str
    """The filename for the resliced output image"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.moving))
        cargs.append(self.output)
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> GreedyResliceMovingImageOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `GreedyResliceMovingImageOutputs`).
        """
        ret = GreedyResliceMovingImageOutputs(
            root=execution.output_file("."),
            resliced_image=execution.output_file(self.output),
        )
        return ret


class GreedyResliceSurfaceOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyResliceSurface | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    warped_mesh: OutputPathType
    """The warped output mesh"""


@dataclasses.dataclass
class GreedyResliceSurface:
    """
    Fixed/output surface pair (vertices are warped from fixed space to moving).
    """
    inmesh: InputPathType
    """The input mesh file"""
    outmesh: str
    """The filename for the output warped mesh"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.inmesh))
        cargs.append(self.outmesh)
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> GreedyResliceSurfaceOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `GreedyResliceSurfaceOutputs`).
        """
        ret = GreedyResliceSurfaceOutputs(
            root=execution.output_file("."),
            warped_mesh=execution.output_file(self.outmesh),
        )
        return ret


class GreedyResliceSimplexJacobianOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GreedyResliceSimplexJacobian | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    jacobian_mesh: OutputPathType
    """The output mesh with computed Jacobian determinants"""


@dataclasses.dataclass
class GreedyResliceSimplexJacobian:
    """
    Compute Jacobian determinant for a simplex mesh in fixed space.
    """
    inmesh: InputPathType
    """The input simplex mesh file"""
    outmesh: str
    """The filename for the output mesh with Jacobian determinants"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.inmesh))
        cargs.append(self.outmesh)
        return cargs
    
    def outputs(
        self,
        execution: Execution,
    ) -> GreedyResliceSimplexJacobianOutputs:
        """
        Collect output file paths.
        
        Args:
            execution: The execution object.
        Returns:
            NamedTuple of outputs (described in `GreedyResliceSimplexJacobianOutputs`).
        """
        ret = GreedyResliceSimplexJacobianOutputs(
            root=execution.output_file("."),
            jacobian_mesh=execution.output_file(self.outmesh),
        )
        return ret


class GreedyOutputs(typing.NamedTuple):
    """
    Output object returned when calling `greedy_(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType | None
    """Output file from affine or deformable registration"""
    invert: GreedyInvertOutputs | None
    """Outputs from `GreedyInvert`."""
    root_: GreedyRootOutputs | None
    """Outputs from `GreedyRoot`."""
    jacobian: GreedyJacobianOutputs | None
    """Outputs from `GreedyJacobian`."""
    reslice_moving_image: GreedyResliceMovingImageOutputs | None
    """Outputs from `GreedyResliceMovingImage`."""
    reslice_surface: GreedyResliceSurfaceOutputs | None
    """Outputs from `GreedyResliceSurface`."""
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianOutputs | None
    """Outputs from `GreedyResliceSimplexJacobian`."""


def greedy_(
    dimensions: int,
    input_images: GreedyInputImages | None = None,
    output: str | None = None,
    affine: bool = False,
    brute: str | None = None,
    moments: typing.Literal[1, 2] | None = None,
    reslice: list[InputPathType] | None = None,
    invert: GreedyInvert | None = None,
    root: GreedyRoot | None = None,
    jacobian: GreedyJacobian | None = None,
    metric_mode: bool = False,
    defopt: bool = False,
    weight: float | None = None,
    metric: GreedyMetric | None = None,
    step_size: str | None = None,
    iterations: str | None = None,
    threads: int | None = None,
    fixed_mask: InputPathType | None = None,
    gm_trim: float | None = None,
    moving_mask: InputPathType | None = None,
    wncc_mask_dilate: bool = False,
    reference_image: InputPathType | None = None,
    ref_pad: float | None = None,
    background: str | None = None,
    input_transform: InputPathType | None = None,
    zero_last_dimension: bool = False,
    time_step_mode: typing.Literal["CONST", "SCALE", "SCALEDOWN"] | None = None,
    smoothing: str | None = None,
    inverse_warp: InputPathType | None = None,
    root_warp: InputPathType | None = None,
    warp_precision: float | None = None,
    noise: float | None = None,
    exponent: float | None = None,
    svf_mode: bool = False,
    svlb: bool = False,
    sv_incompr: bool = False,
    initial_warp: InputPathType | None = None,
    tjr: GreedyTjr | None = None,
    wr: float | None = None,
    initial_affine: InputPathType | None = None,
    ia_identity: bool = False,
    ia_voxel_grid: bool = False,
    ia_image_centers: bool = False,
    ia_image_side: str | None = None,
    ia_moments: typing.Literal[1, 2] | None = None,
    affine_dof: typing.Literal[6, 7, 12] | None = None,
    jitter: float | None = None,
    search: GreedySearch | None = None,
    det: typing.Literal[-1, 1] | None = None,
    cov_id: bool = False,
    fixed_reslicing_image: InputPathType | None = None,
    reslice_moving_image: GreedyResliceMovingImage | None = None,
    reslice_surface: GreedyResliceSurface | None = None,
    interpolation: typing.Literal["NN", "LINEAR", "LABEL"] | None = None,
    reslice_background: float | None = None,
    reslice_datatype: typing.Literal["auto", "double", "float", "uint", "int", "ushort", "short", "uchar", "char"] | None = None,
    reslice_composite: InputPathType | None = None,
    reslice_jacobian: InputPathType | None = None,
    reslice_simplex_jacobian: GreedyResliceSimplexJacobian | None = None,
    reslice_mask: InputPathType | None = None,
    metric_gradient: InputPathType | None = None,
    debug_deriv: bool = False,
    debug_deriv_eps: float | None = None,
    debug_aff_obj: bool = False,
    dump_pyramid: bool = False,
    dump_moving: bool = False,
    dump_frequency: float | None = None,
    dump_prefix: str | None = None,
    powell: bool = False,
    float_: bool = False,
    version: bool = False,
    verbosity: typing.Literal[0, 1, 2] | None = None,
    runner: Runner | None = None,
) -> GreedyOutputs:
    """
    Paul's greedy diffeomorphic registration implementation.
    
    Author: Greedy Developers
    
    URL: https://sites.google.com/view/greedyreg/about
    
    Args:
        dimensions: Number of image dimensions.
        input_images: Image pair (may be repeated).
        output: Output file (matrix in affine mode; image in deformable mode,\
            metric computation mode; ignored in reslicing mode).
        affine: Perform affine registration and save to output (-o).
        brute: Perform a brute force search around each voxel.
        moments: Perform moments of inertia rigid alignment of given order (1\
            or 2).
        reslice: Reslice images instead of doing registration.
        invert: Invert previously computed warp.
        root: Convert 2^N-th root of a warp.
        jacobian: Compute the Jacobian determinant of the warp.
        metric_mode: Compute metric between images.
        defopt: Deformable optimization mode (experimental).
        weight: Weight of the next -i pair.
        metric: Metric for the entire registration.
        step_size: Step size for optimization (default = 1.0), may also be\
            specified per level (e.g. 0.3x0.1).
        iterations: Number of iterations per level of multi-res.
        threads: Number of allowed concurrent threads.
        fixed_mask: Fixed image mask (metric gradients computed only over the\
            mask).
        gm_trim: Generate the fixed image mask by trimming the extent of the\
            fixed image by given radius.
        moving_mask: Moving image mask (pixels outside are excluded from metric\
            computation).
        wncc_mask_dilate: Specifies that fixed and moving masks should be\
            dilated by the radius of the WNCC metric during registration.
        reference_image: Use supplied image, rather than fixed image to define\
            the reference space.
        ref_pad: Define the reference space by padding the fixed image by\
            radius.
        background: Value to fill missing values when mapping fixed and moving\
            images to reference space.
        input_transform: Specify transforms (matrices, warps) that map moving\
            image to reference space.
        zero_last_dimension: Sets sigmas and NCC radius to zero in the last\
            dimension for 2D/3D registration.
        time_step_mode: Time step behavior mode.
        smoothing: Smoothing for the greedy update step (e.g., '1.732vox\
            0.7071vox').
        inverse_warp: Compute and write the inverse of the warp field.
        root_warp: Compute and write the (2^N-th) root of the warp field.
        warp_precision: Saved warp precision in voxels (default=0.1; 0 for no\
            compression).
        noise: Standard deviation of white noise added to moving/fixed images\
            when using NCC metric.
        exponent: The exponent used for warp inversion, root computation, and\
            in stationary velocity field mode.
        svf_mode: Perform registration using the stationary velocity model.
        svlb: Use more accurate but expensive update of v in stationary\
            velocity field mode.
        sv_incompr: Incompressibility mode, implements Mansi et al. 2011\
            iLogDemons.
        initial_warp: Specifies the initial warp to start iteration from.
        tjr: Apply a regularization penalty based on the Jacobian of a\
            tetrahedral mesh.
        wr: Weight of SVF smoothness regularization term (default: 1000).
        initial_affine: Initial affine matrix for optimization.
        ia_identity: Initialize affine matrix based on NIFTI headers.
        ia_voxel_grid: Initialize affine matrix so that voxels with\
            corresponding indices align.
        ia_image_centers: Initialize affine matrix based on matching image\
            centers.
        ia_image_side: Initialize affine matrix based on matching center of one\
            image side.
        ia_moments: Initialize affine matrix based on matching moments of\
            inertia.
        affine_dof: Degrees of freedom for affine registration. 6=rigid,\
            7=similarity, 12=affine.
        jitter: Jitter (in voxel units) applied to sample points (default: 0.5).
        search: Random search over rigid transforms before starting\
            optimization.
        det: Force the determinant of transform to be either 1 (no flip) or -1\
            (flip).
        cov_id: Assume identity covariance (match centers and do flips only, no\
            rotation).
        fixed_reslicing_image: Fixed image for reslicing.
        reslice_moving_image: Moving/output image pair for reslicing.
        reslice_surface: Fixed/output surface pair (vertices are warped from\
            fixed space to moving).
        interpolation: Interpolation for the next pair (NN, LINEAR*, LABEL\
            sigma).
        reslice_background: Background (i.e. outside) intensity for the next\
            pair (default 0).
        reslice_datatype: Data type for the next pair.
        reslice_composite: Write composed transforms to outwarp.
        reslice_jacobian: Write Jacobian determinant image to outjacobian.
        reslice_simplex_jacobian: Compute Jacobian determinant for a simplex\
            mesh in fixed space.
        reslice_mask: A binary mask for the fixed image; zero values will be\
            overwritten with background.
        metric_gradient: Write the gradient of the metric to file.
        debug_deriv: Enable periodic checks of derivatives (debug).
        debug_deriv_eps: Epsilon for derivative debugging.
        debug_aff_obj: Plot affine objective in neighborhood of -ia matrix.
        dump_pyramid: Dump the image pyramid at the start of the registration.
        dump_moving: Dump moving image at each iter.
        dump_frequency: Dump frequency.
        dump_prefix: Prefix for dump files (may be a path).
        powell: Use Powell's method instead of LGBFS.
        float_: Use single precision floating point (off by default).
        version: Print version info.
        verbosity: Verbosity level (0: none, 1: default, 2: verbose).
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `GreedyOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(GREEDY_METADATA)
    cargs = []
    cargs.append("greedy")
    cargs.extend([
        "-d",
        str(dimensions)
    ])
    if input_images is not None:
        cargs.extend([
            "-i",
            *input_images.run(execution)
        ])
    if output is not None:
        cargs.extend([
            "-o",
            output
        ])
    if affine:
        cargs.append("-a")
    if brute is not None:
        cargs.extend([
            "-brute",
            brute
        ])
    if moments is not None:
        cargs.extend([
            "-moments",
            str(moments)
        ])
    if reslice is not None:
        cargs.extend([
            "-r",
            *[execution.input_file(f) for f in reslice]
        ])
    if invert is not None:
        cargs.extend([
            "-iw",
            *invert.run(execution)
        ])
    if root is not None:
        cargs.extend([
            "-root",
            *root.run(execution)
        ])
    if jacobian is not None:
        cargs.extend([
            "-jac",
            *jacobian.run(execution)
        ])
    if metric_mode:
        cargs.append("-metric")
    if defopt:
        cargs.append("-defopt")
    if weight is not None:
        cargs.extend([
            "-w",
            str(weight)
        ])
    if metric is not None:
        cargs.extend([
            "-m",
            *metric.run(execution)
        ])
    if step_size is not None:
        cargs.extend([
            "-e",
            step_size
        ])
    if iterations is not None:
        cargs.extend([
            "-n",
            iterations
        ])
    if threads is not None:
        cargs.extend([
            "-threads",
            str(threads)
        ])
    if fixed_mask is not None:
        cargs.extend([
            "-gm",
            execution.input_file(fixed_mask)
        ])
    if gm_trim is not None:
        cargs.extend([
            "-gm-trim",
            str(gm_trim)
        ])
    if moving_mask is not None:
        cargs.extend([
            "-mm",
            execution.input_file(moving_mask)
        ])
    if wncc_mask_dilate:
        cargs.append("-wncc-mask-dilate")
    if reference_image is not None:
        cargs.extend([
            "-ref",
            execution.input_file(reference_image)
        ])
    if ref_pad is not None:
        cargs.extend([
            "-ref-pad",
            str(ref_pad)
        ])
    if background is not None:
        cargs.extend([
            "-bg",
            background
        ])
    if input_transform is not None:
        cargs.extend([
            "-it",
            execution.input_file(input_transform)
        ])
    if zero_last_dimension:
        cargs.append("-z")
    if time_step_mode is not None:
        cargs.extend([
            "-tscale",
            time_step_mode
        ])
    if smoothing is not None:
        cargs.extend([
            "-s",
            smoothing
        ])
    if inverse_warp is not None:
        cargs.extend([
            "-oinv",
            execution.input_file(inverse_warp)
        ])
    if root_warp is not None:
        cargs.extend([
            "-oroot",
            execution.input_file(root_warp)
        ])
    if warp_precision is not None:
        cargs.extend([
            "-wp",
            str(warp_precision)
        ])
    if noise is not None:
        cargs.extend([
            "-noise",
            str(noise)
        ])
    if exponent is not None:
        cargs.extend([
            "-exp",
            str(exponent)
        ])
    if svf_mode:
        cargs.append("-sv")
    if svlb:
        cargs.append("-svlb")
    if sv_incompr:
        cargs.append("-sv-incompr")
    if initial_warp is not None:
        cargs.extend([
            "-id",
            execution.input_file(initial_warp)
        ])
    if tjr is not None:
        cargs.extend([
            "-tjr",
            *tjr.run(execution)
        ])
    if wr is not None:
        cargs.extend([
            "-wr",
            str(wr)
        ])
    if initial_affine is not None:
        cargs.extend([
            "-ia",
            execution.input_file(initial_affine)
        ])
    if ia_identity:
        cargs.append("-ia-identity")
    if ia_voxel_grid:
        cargs.append("-ia-voxel-grid")
    if ia_image_centers:
        cargs.append("-ia-image-centers")
    if ia_image_side is not None:
        cargs.extend([
            "-ia-image-side",
            ia_image_side
        ])
    if ia_moments is not None:
        cargs.extend([
            "-ia-moments",
            str(ia_moments)
        ])
    if affine_dof is not None:
        cargs.extend([
            "-dof",
            str(affine_dof)
        ])
    if jitter is not None:
        cargs.extend([
            "-jitter",
            str(jitter)
        ])
    if search is not None:
        cargs.extend([
            "-search",
            *search.run(execution)
        ])
    if det is not None:
        cargs.extend([
            "-det",
            str(det)
        ])
    if cov_id:
        cargs.append("-cov-id")
    if fixed_reslicing_image is not None:
        cargs.extend([
            "-rf",
            execution.input_file(fixed_reslicing_image)
        ])
    if reslice_moving_image is not None:
        cargs.extend([
            "-rm",
            *reslice_moving_image.run(execution)
        ])
    if reslice_surface is not None:
        cargs.extend([
            "-rs",
            *reslice_surface.run(execution)
        ])
    if interpolation is not None:
        cargs.extend([
            "-ri",
            interpolation
        ])
    if reslice_background is not None:
        cargs.extend([
            "-rb",
            str(reslice_background)
        ])
    if reslice_datatype is not None:
        cargs.extend([
            "-rt",
            reslice_datatype
        ])
    if reslice_composite is not None:
        cargs.extend([
            "-rc",
            execution.input_file(reslice_composite)
        ])
    if reslice_jacobian is not None:
        cargs.extend([
            "-rj",
            execution.input_file(reslice_jacobian)
        ])
    if reslice_simplex_jacobian is not None:
        cargs.extend([
            "-rsj",
            *reslice_simplex_jacobian.run(execution)
        ])
    if reslice_mask is not None:
        cargs.extend([
            "-rk",
            execution.input_file(reslice_mask)
        ])
    if metric_gradient is not None:
        cargs.extend([
            "-og",
            execution.input_file(metric_gradient)
        ])
    if debug_deriv:
        cargs.append("-debug-deriv")
    if debug_deriv_eps is not None:
        cargs.extend([
            "-debug-deriv-eps",
            str(debug_deriv_eps)
        ])
    if debug_aff_obj:
        cargs.append("-debug-aff-obj")
    if dump_pyramid:
        cargs.append("-dump-pyramid")
    if dump_moving:
        cargs.append("-dump-moving")
    if dump_frequency is not None:
        cargs.extend([
            "-dump-freq",
            str(dump_frequency)
        ])
    if dump_prefix is not None:
        cargs.extend([
            "-dump-prefix",
            dump_prefix
        ])
    if powell:
        cargs.append("-powell")
    if float_:
        cargs.append("-float")
    if version:
        cargs.append("-version")
    if verbosity is not None:
        cargs.extend([
            "-V",
            str(verbosity)
        ])
    ret = GreedyOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(output) if (output is not None) else None,
        invert=invert.outputs(execution) if invert else None,
        root_=root.outputs(execution) if root else None,
        jacobian=jacobian.outputs(execution) if jacobian else None,
        reslice_moving_image=reslice_moving_image.outputs(execution) if reslice_moving_image else None,
        reslice_surface=reslice_surface.outputs(execution) if reslice_surface else None,
        reslice_simplex_jacobian=reslice_simplex_jacobian.outputs(execution) if reslice_simplex_jacobian else None,
    )
    execution.run(cargs)
    return ret


__all__ = [
    "GREEDY_METADATA",
    "GreedyInputImages",
    "GreedyInvert",
    "GreedyInvertOutputs",
    "GreedyJacobian",
    "GreedyJacobianOutputs",
    "GreedyMetric",
    "GreedyOutputs",
    "GreedyResliceMovingImage",
    "GreedyResliceMovingImageOutputs",
    "GreedyResliceSimplexJacobian",
    "GreedyResliceSimplexJacobianOutputs",
    "GreedyResliceSurface",
    "GreedyResliceSurfaceOutputs",
    "GreedyRoot",
    "GreedyRootOutputs",
    "GreedySearch",
    "GreedyTjr",
    "greedy_",
]
