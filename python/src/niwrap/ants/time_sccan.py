# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *
import dataclasses

TIME_SCCAN_METADATA = Metadata(
    id="c29edfffbdbeee9e02e8801bed3cb5f939e9ea50.boutiques",
    name="TimeSCCAN",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


@dataclasses.dataclass
class TimeSccanTimeseriesimageToMatrix:
    """
    Takes a timeseries (4D) image and converts it to a 2D matrix csv format as
    output. If the mask has multiple labels (more than one), then the average
    time series in each label will be computed and put in the csv.
    """
    timeseries_image: InputPathType
    mask_image: InputPathType
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append(execution.input_file(self.timeseries_image) + execution.input_file(self.mask_image))
        return cargs


@dataclasses.dataclass
class TimeSccanNetworkScca:
    time_matrix: InputPathType
    label_matrix: InputPathType
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("scca[" + execution.input_file(self.time_matrix) + "," + execution.input_file(self.label_matrix) + "]")
        return cargs


@dataclasses.dataclass
class TimeSccanNetworkRegionAveraging:
    time_matrix: InputPathType
    label_matrix: InputPathType
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            execution: The execution object.
        Returns:
            Command line arguments
        """
        cargs = []
        cargs.append("region-averaging[" + execution.input_file(self.time_matrix) + "," + execution.input_file(self.label_matrix) + "]")
        return cargs


class TimeSccanOutputs(typing.NamedTuple):
    """
    Output object returned when calling `time_sccan(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    correlation_matrix: OutputPathType
    """The output is the 2D correlation matrix."""


def time_sccan(
    output: InputPathType,
    number_consecutive_labels: int | None = 0,
    minimum_region_size: int | None = 1,
    iterations: int | None = 20,
    sparsity: float | None = 0.1,
    n_eigenvectors: int | None = 2,
    robustify: int | None = 0,
    l1: float | None = 0,
    cluster_thresh: int | None = 1,
    ridge_cca: int | None = 0,
    partial_scca_option: typing.Literal["PQ", "PminusRQ", "PQminusR", "PminusRQminusR"] | None = None,
    timeseriesimage_to_matrix: TimeSccanTimeseriesimageToMatrix | None = None,
    labelsimage_to_matrix: InputPathType | None = None,
    network: typing.Union[TimeSccanNetworkScca, TimeSccanNetworkRegionAveraging] | None = None,
    runner: Runner | None = None,
) -> TimeSccanOutputs:
    """
    A tool for sparse statistical analysis on connectivity within a subject.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        output: Output is a 2D correlation matrix.
        number_consecutive_labels: Number of consecutive labels in data.
        minimum_region_size: Minimum size of a region: regions below this size\
            are given a 0.0 connectivity value.
        iterations: Number of iterations.
        sparsity: Sparsity - a float from (0,1] indicating what fraction of the\
            data to use.
        n_eigenvectors: Number of permutations to use in scca.
        robustify: Rank-based scca.
        l1: Use l1 ( > 0 ) or l0 ( < 0 ) penalty, also sets gradient step size\
            e.g. -l 0.5 ( L1 ) , -l -0.5 (L0) will set 0.5 grad descent step for\
            either penalty.
        cluster_thresh: Cluster threshold on view P.
        ridge_cca: Number of permutations to use in scca.
        partial_scca_option: Choices for partial SCCA: PQ, PminusRQ, PQminusR,\
            PminusRQminusR.
        timeseriesimage_to_matrix: Takes a timeseries (4D) image and converts\
            it to a 2D matrix csv format as output. If the mask has multiple labels\
            (more than one), then the average time series in each label will be\
            computed and put in the csv.
        labelsimage_to_matrix: Takes a labeled (3D) image and converts it to a\
            2D matrix csv format as output.
        network: Build the network connectivity matrix.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TimeSccanOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(TIME_SCCAN_METADATA)
    cargs = []
    cargs.append("TimeSCCAN")
    cargs.extend([
        "--output",
        execution.input_file(output)
    ])
    if number_consecutive_labels is not None:
        cargs.extend([
            "-l",
            str(number_consecutive_labels)
        ])
    if minimum_region_size is not None:
        cargs.extend([
            "-R",
            str(minimum_region_size)
        ])
    if iterations is not None:
        cargs.extend([
            "-i",
            str(iterations)
        ])
    if sparsity is not None:
        cargs.extend([
            "-s",
            str(sparsity)
        ])
    if n_eigenvectors is not None:
        cargs.extend([
            "-n",
            str(n_eigenvectors)
        ])
    if robustify is not None:
        cargs.extend([
            "-r",
            str(robustify)
        ])
    if l1 is not None:
        cargs.extend([
            "-l",
            str(l1)
        ])
    if cluster_thresh is not None:
        cargs.extend([
            "--ClusterThresh",
            str(cluster_thresh)
        ])
    if ridge_cca is not None:
        cargs.extend([
            "-e",
            str(ridge_cca)
        ])
    if partial_scca_option is not None:
        cargs.extend([
            "--partial-scca-option",
            partial_scca_option
        ])
    if timeseriesimage_to_matrix is not None:
        cargs.extend([
            "--timeseriesimage-to-matrix",
            *timeseriesimage_to_matrix.run(execution)
        ])
    if labelsimage_to_matrix is not None:
        cargs.extend([
            "--labelsimage-to-matrix",
            execution.input_file(labelsimage_to_matrix)
        ])
    if network is not None:
        cargs.extend([
            "--network",
            *network.run(execution)
        ])
    ret = TimeSccanOutputs(
        root=execution.output_file("."),
        correlation_matrix=execution.output_file(pathlib.Path(output).name),
    )
    execution.run(cargs)
    return ret


__all__ = [
    "TIME_SCCAN_METADATA",
    "TimeSccanNetworkRegionAveraging",
    "TimeSccanNetworkScca",
    "TimeSccanOutputs",
    "TimeSccanTimeseriesimageToMatrix",
    "time_sccan",
]
