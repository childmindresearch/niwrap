# This file was auto generated by styx
# Do not edit this file directly

import typing

from ..styxdefs import *


VOLUME_TO_SURFACE_MAPPING_METADATA = Metadata(
    id="87171a487d1622d5f5679b49bcae03b441cd8456",
    name="volume-to-surface-mapping",
    container_image_type="docker",
    container_image_tag="mcin/docker-fsl:latest",
)


class VolumeToSurfaceMappingOutputs(typing.NamedTuple):
    """
    Output object returned when calling `volume_to_surface_mapping(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    metric_out: OutputPathType
    """the output metric file"""


def volume_to_surface_mapping(
    runner: Runner,
    volume: InputPathType,
    surface: InputPathType,
    metric_out: InputPathType,
    opt_trilinear: bool = False,
    opt_enclosing: bool = False,
    opt_cubic: bool = False,
    opt_subvol_select_subvol: str | None = None,
) -> VolumeToSurfaceMappingOutputs:
    """
    MAP VOLUME TO SURFACE.
    
    You must specify exactly one mapping method. Enclosing voxel uses the value
    from the voxel the vertex lies inside, while trilinear does a 3D linear
    interpolation based on the voxels immediately on each side of the vertex's
    position.
    
    The ribbon mapping method constructs a polyhedron from the vertex's
    neighbors on each surface, and estimates the amount of this polyhedron's
    volume that falls inside any nearby voxels, to use as the weights for
    sampling. If -thin-columns is specified, the polyhedron uses the edge
    midpoints and triangle centroids, so that neighboring vertices do not have
    overlapping polyhedra. This may require increasing -voxel-subdiv to get
    enough samples in each voxel to reliably land inside these smaller
    polyhedra. The volume ROI is useful to exclude partial volume effects of
    voxels the surfaces pass through, and will cause the mapping to ignore
    voxels that don't have a positive value in the mask. The subdivision number
    specifies how it approximates the amount of the volume the polyhedron
    intersects, by splitting each voxel into NxNxN pieces, and checking whether
    the center of each piece is inside the polyhedron. If you have very large
    voxels, consider increasing this if you get zeros in your output. The
    -gaussian option makes it act more like the myelin method, where the
    distance of a voxel from <surface> is used to downweight the voxel. The
    -interpolate suboption, instead of doing a weighted average of voxels,
    interpolates from the volume at the subdivided points inside the ribbon. If
    using both -interpolate and the -weighted suboption to -volume-roi, the roi
    volume weights are linearly interpolated, unless the -interpolate method is
    ENCLOSING_VOXEL, in which case ENCLOSING_VOXEL is also used for sampling the
    roi volume weights.
    
    The myelin style method uses part of the caret5 myelin mapping command to do
    the mapping: for each surface vertex, take all voxels that are in a cylinder
    with radius and height equal to cortical thickness, centered on the vertex
    and aligned with the surface normal, and that are also within the ribbon
    ROI, and apply a gaussian kernel with the specified sigma to them to get the
    weights to use. The -legacy-bug flag reverts to the unintended behavior
    present from the initial implementation up to and including v1.2.3, which
    had only the tangential cutoff and a bounding box intended to be larger than
    where the cylinder cutoff should have been.
    
    Args:
        runner: Command runner
        volume: the volume to map data from
        surface: the surface to map the data onto
        metric_out: the output metric file
        opt_trilinear: use trilinear volume interpolation
        opt_enclosing: use value of the enclosing voxel
        opt_cubic: use cubic splines
        opt_subvol_select_subvol: select a single subvolume to map: the
            subvolume number or name
    Returns:
        NamedTuple of outputs (described in `VolumeToSurfaceMappingOutputs`).
    """
    execution = runner.start_execution(VOLUME_TO_SURFACE_MAPPING_METADATA)
    cargs = []
    cargs.append("wb_command")
    cargs.append("-volume-to-surface-mapping")
    cargs.append(execution.input_file(volume))
    cargs.append(execution.input_file(surface))
    cargs.append(execution.input_file(metric_out))
    if opt_trilinear:
        cargs.append("-trilinear")
    if opt_enclosing:
        cargs.append("-enclosing")
    if opt_cubic:
        cargs.append("-cubic")
    if opt_subvol_select_subvol is not None:
        cargs.extend(["-subvol-select", opt_subvol_select_subvol])
    ret = VolumeToSurfaceMappingOutputs(
        root=execution.output_file("."),
        metric_out=execution.output_file(f"{pathlib.Path(metric_out).stem}"),
    )
    execution.run(cargs)
    return ret
