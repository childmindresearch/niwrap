# This file was auto generated by styx
# Do not edit this file directly

import typing

from ..styxdefs import *


SURFACE_APPLY_WARPFIELD_METADATA = Metadata(
    id="53317c75ffa21bb0cf2681a0839af8212bf67ba3",
    name="surface-apply-warpfield",
    container_image_type="docker",
    container_image_tag="mcin/docker-fsl:latest",
)


class SurfaceApplyWarpfieldOutputs(typing.NamedTuple):
    """
    Output object returned when calling `surface_apply_warpfield(...)`.
    """
    out_surf: OutputPathType
    """the output transformed surface"""


def surface_apply_warpfield(
    runner: Runner,
    in_surf: InputPathType,
    warpfield: str,
    out_surf: InputPathType,
    opt_fnirt_forward_warp: str | None = None,
) -> SurfaceApplyWarpfieldOutputs:
    """
    APPLY WARPFIELD TO SURFACE FILE.
    
    NOTE: warping a surface requires the INVERSE of the warpfield used to warp
    the volume it lines up with. The header of the forward warp is needed by the
    -fnirt option in order to correctly interpret the displacements in the fnirt
    warpfield.
    
    If the -fnirt option is not present, the warpfield must be a nifti 'world'
    warpfield, which can be obtained with the -convert-warpfield command.
    
    Args:
        runner: Command runner
        in_surf: the surface to transform
        warpfield: the INVERSE warpfield
        out_surf: the output transformed surface
        opt_fnirt_forward_warp: MUST be used if using a fnirt warpfield: the
            forward warpfield
    Returns:
        NamedTuple of outputs (described in `SurfaceApplyWarpfieldOutputs`).
    """
    execution = runner.start_execution(SURFACE_APPLY_WARPFIELD_METADATA)
    cargs = []
    cargs.append("wb_command")
    cargs.append("-surface-apply-warpfield")
    cargs.append(execution.input_file(in_surf))
    cargs.append(warpfield)
    cargs.append(execution.input_file(out_surf))
    if opt_fnirt_forward_warp is not None:
        cargs.extend(["-fnirt", opt_fnirt_forward_warp])
    ret = SurfaceApplyWarpfieldOutputs(
        out_surf=execution.output_file(f"{out_surf}"),
    )
    execution.run(cargs)
    return ret
