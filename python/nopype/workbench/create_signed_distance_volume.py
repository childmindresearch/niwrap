# This file was auto generated by styx
# Do not edit this file directly

import typing

from ..styxdefs import *


CREATE_SIGNED_DISTANCE_VOLUME_METADATA = Metadata(
    id="fc5fa9a2bfb0788dd3ca0b0bccd8c58fffc8a33d",
    name="create-signed-distance-volume",
    container_image_type="docker",
    container_image_tag="mcin/docker-fsl:latest",
)


class CreateSignedDistanceVolumeOutputs(typing.NamedTuple):
    """
    Output object returned when calling `create_signed_distance_volume(...)`.
    """
    outvol: OutputPathType
    """the output volume"""


def create_signed_distance_volume(
    runner: Runner,
    surface: InputPathType,
    refspace: str,
    outvol: InputPathType,
    opt_roi_out: bool = False,
    opt_fill_value_value: float | int | None = None,
    opt_exact_limit_dist: float | int | None = None,
    opt_approx_limit_dist: float | int | None = None,
    opt_approx_neighborhood_num: float | int | None = None,
    opt_winding_method: str | None = None,
) -> CreateSignedDistanceVolumeOutputs:
    """
    CREATE SIGNED DISTANCE VOLUME FROM SURFACE.
    
    Computes the signed distance function of the surface. Exact distance is
    calculated by finding the closest point on any surface triangle to the
    center of the voxel. Approximate distance is calculated starting with these
    distances, using dijkstra's method with a neighborhood of voxels. Specifying
    too small of an exact distance may produce unexpected results. Valid
    specifiers for winding methods are as follows:
    
    EVEN_ODD (default)
    NEGATIVE
    NONZERO
    NORMALS
    
    The NORMALS method uses the normals of triangles and edges, or the closest
    triangle hit by a ray from the point. This method may be slightly faster,
    but is only reliable for a closed surface that does not cross through
    itself. All other methods count entry (positive) and exit (negative)
    crossings of a vertical ray from the point, then counts as inside if the
    total is odd, negative, or nonzero, respectively.
    
    Args:
        runner: Command runner
        surface: the input surface
        refspace: a volume in the desired output space (dims, spacing, origin)
        outvol: the output volume
        opt_roi_out: output an roi volume of where the output has a computed
            value
        opt_fill_value_value: specify a value to put in all voxels that don't
            get assigned a distance: value to fill with (default 0)
        opt_exact_limit_dist: specify distance for exact output: distance in mm
            (default 5)
        opt_approx_limit_dist: specify distance for approximate output: distance
            in mm (default 20)
        opt_approx_neighborhood_num: voxel neighborhood for approximate
            calculation: size of neighborhood cube measured from center to face, in
            voxels (default 2 = 5x5x5)
        opt_winding_method: winding method for point inside surface test: name
            of the method (default EVEN_ODD)
    Returns:
        NamedTuple of outputs (described in `CreateSignedDistanceVolumeOutputs`).
    """
    execution = runner.start_execution(CREATE_SIGNED_DISTANCE_VOLUME_METADATA)
    cargs = []
    cargs.append("wb_command")
    cargs.append("-create-signed-distance-volume")
    cargs.append(execution.input_file(surface))
    cargs.append(refspace)
    cargs.append(execution.input_file(outvol))
    if opt_roi_out:
        cargs.append("-roi-out")
    if opt_fill_value_value is not None:
        cargs.extend(["-fill-value", str(opt_fill_value_value)])
    if opt_exact_limit_dist is not None:
        cargs.extend(["-exact-limit", str(opt_exact_limit_dist)])
    if opt_approx_limit_dist is not None:
        cargs.extend(["-approx-limit", str(opt_approx_limit_dist)])
    if opt_approx_neighborhood_num is not None:
        cargs.extend(["-approx-neighborhood", str(opt_approx_neighborhood_num)])
    if opt_winding_method is not None:
        cargs.extend(["-winding", opt_winding_method])
    ret = CreateSignedDistanceVolumeOutputs(
        outvol=execution.output_file(f"{outvol}"),
    )
    execution.run(cargs)
    return ret
