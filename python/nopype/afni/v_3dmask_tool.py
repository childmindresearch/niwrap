# This file was auto generated by styx
# Do not edit this file directly

import typing

from ..styxdefs import *


V_3DMASK_TOOL_METADATA = Metadata(
    id="56fe502e82c965e3e9e167330f352c57a171d14f",
    name="3dmask_tool",
    container_image_type="docker",
    container_image_tag="fcpindi/c-pac:latest",
)


class V3dmaskToolOutputs(typing.NamedTuple):
    """
    Output object returned when calling `v_3dmask_tool(...)`.
    """
    out_file: OutputPathType
    """Output image file name."""
    out_file_: OutputPathType
    """Mask file."""


def v_3dmask_tool(
    runner: Runner,
    in_file: list[InputPathType],
    count: bool = False,
    datum: typing.Literal["byte", "short", "float"] | None = None,
    dilate_inputs: str | None = None,
    dilate_results: str | None = None,
    fill_dirs: str | None = None,
    fill_holes: bool = False,
    frac: float | int | None = None,
    inter: bool = False,
    num_threads: int | None = 1,
    outputtype: typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None = None,
    union: bool = False,
    verbose: int | None = None,
) -> V3dmaskToolOutputs:
    """
    MaskTool, as implemented in Nipype (module: nipype.interfaces.afni, interface:
    MaskTool).
    3dmask_tool - for combining/dilating/eroding/filling masks
    For complete details, see the `3dmask_tool Documentation.
    <https://afni.nimh.nih.gov/pub../pub/dist/doc/program_help/3dmask_tool.html>`_
    
    Args:
        runner: Command runner
        in_file: Input file or files to 3dmask_tool.
        count: Instead of created a binary 0/1 mask dataset, create one with
            counts of voxel overlap, i.e., each voxel will contain the number of
            masks that it is set in.
        datum: 'byte' or 'short' or 'float'. Specify data type for output.
        dilate_inputs: Use this option to dilate and/or erode datasets as they
            are read. ex. '5 -5' to dilate and erode 5 times.
        dilate_results: Dilate and/or erode combined mask at the given levels.
        fill_dirs: Fill holes only in the given directions. this option is for
            use with -fill holes. should be a single string that specifies 1-3 of
            the axes using {x,y,z} labels (i.e. dataset axis order), or using the
            labels in {r,l,a,p,i,s}.
        fill_holes: This option can be used to fill holes in the resulting mask,
            i.e. after all other processing has been done.
        frac: When combining masks (across datasets and sub-bricks), use this
            option to restrict the result to a certain fraction of the set of
            volumes.
        inter: Intersection, this means -frac 1.0.
        num_threads: Set number of threads.
        outputtype: 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
        union: Union, this means -frac 0.
        verbose: Specify verbosity level, for 0 to 3.
    Returns:
        NamedTuple of outputs (described in `V3dmaskToolOutputs`).
    """
    execution = runner.start_execution(V_3DMASK_TOOL_METADATA)
    cargs = []
    cargs.append("3dmask_tool")
    if count:
        cargs.append("-count")
    cargs.extend(["-input", *[execution.input_file(f) for f in in_file]])
    cargs.append("[ARGS]")
    if datum is not None:
        cargs.extend(["-datum", datum])
    if dilate_inputs is not None:
        cargs.extend(["-dilate_inputs", dilate_inputs])
    if dilate_results is not None:
        cargs.extend(["-dilate_results", dilate_results])
    cargs.append("[ENVIRON]")
    if fill_dirs is not None:
        cargs.extend(["-fill_dirs", fill_dirs])
    if fill_holes:
        cargs.append("-fill_holes")
    if frac is not None:
        cargs.extend(["-frac", str(frac)])
    if inter:
        cargs.append("-inter")
    if num_threads is not None:
        cargs.append(str(num_threads))
    cargs.append("[OUT_FILE]")
    if outputtype is not None:
        cargs.append(outputtype)
    if union:
        cargs.append("-union")
    if verbose is not None:
        cargs.extend(["-verb", str(verbose)])
    ret = V3dmaskToolOutputs(
        out_file=execution.output_file(f"{in_file}_mask", optional=True),
        out_file_=execution.output_file(f"out_file", optional=True),
    )
    execution.run(cargs)
    return ret
