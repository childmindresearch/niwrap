# This file was auto generated by styx-boutiques-codegen
# Do not edit this file directly
# Timestamp: 2024-05-16T19:06:12.698667

import typing

from ..styxdefs import *


V_3D_TSHIFT_METADATA = Metadata(
    id="0b2c95afc9b600bfae218e543be95a0527bf5167",
    name="3dTshift",
    container_image_type="docker",
    container_image_tag="fcpindi/c-pac:latest",
)


class V3dTshiftOutputs(typing.NamedTuple):
    """
    Output object returned when calling `v_3d_tshift(...)`.
    """
    out_file: OutputPathType
    """Output image file name."""
    out_file_: OutputPathType
    """Output file."""
    timing_file: OutputPathType
    """Afni formatted timing file, if ``slice_timing`` is a list."""


def v_3d_tshift(
    runner: Runner,
    in_file: InputPathType,
    ignore: int | None = None,
    interp: typing.Literal["Fourier", "linear", "cubic", "quintic", "heptic"] | None = None,
    num_threads: int | None = 1,
    outputtype: typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None = None,
    rlt: bool = False,
    rltplus: bool = False,
    slice_encoding_direction: typing.Literal["k", "k-"] | None = "k",
    slice_timing: InputPathType | None = None,
    slice_timing_2: list[float | int] = None,
    tpattern: typing.Literal["alt+z", "altplus", "alt+z2", "alt-z", "altminus", "alt-z2", "seq+z", "seqplus", "seq-z", "seqminus"] | None = None,
    tpattern_2: str | None = None,
    tr: str | None = None,
    tslice: int | None = None,
    tzero: float | int | None = None,
) -> V3dTshiftOutputs:
    """
    TShift, as implemented in Nipype (module: nipype.interfaces.afni.preprocess,
    interface: TShift).
    Shifts voxel time series from input so that separate slices are aligned to
    the same temporal origin.
    For complete details, see the `3dTshift Documentation.
    <https://afni.nimh.nih.gov/pub/dist/doc/program_help/3dTshift.html>`_
    
    Args:
        runner: Command runner
        in_file: Input file to 3dtshift.
        ignore: Ignore the first set of points specified.
        interp: 'fourier' or 'linear' or 'cubic' or 'quintic' or 'heptic'.
            Different interpolation methods (see 3dtshift for details) default =
            fourier.
        num_threads: Set number of threads.
        outputtype: 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
        rlt: Before shifting, remove the mean and linear trend.
        rltplus: Before shifting, remove the mean and linear trend and later put
            back the mean.
        slice_encoding_direction: 'k' or 'k-'. Direction in which slice_timing
            is specified (default: k). if negative,slice_timing is defined in
            reverse order, that is, the first entry corresponds to the slice with
            the largest index, and the final entry corresponds to slice index zero.
            only in effect when slice_timing is passed as list, not when it is
            passed as file.
        slice_timing: file or string or a list of items which are a float. Time
            offsets from the volume acquisition onset for each slice.
        slice_timing_2: file or string or a list of items which are a float.
            Time offsets from the volume acquisition onset for each slice.
        tpattern: 'alt+z' or 'altplus' or 'alt+z2' or 'alt-z' or 'altminus' or
            'alt-z2' or 'seq+z' or 'seqplus' or 'seq-z' or 'seqminus' or a string.
            Use specified slice time pattern rather than one in header.
        tpattern_2: 'alt+z' or 'altplus' or 'alt+z2' or 'alt-z' or 'altminus' or
            'alt-z2' or 'seq+z' or 'seqplus' or 'seq-z' or 'seqminus' or a string.
            Use specified slice time pattern rather than one in header.
        tr: Manually set the tr. you can attach suffix "s" for seconds or "ms"
            for milliseconds.
        tslice: Align each slice to time offset of given slice.
        tzero: Align each slice to given time offset.
    Returns:
        NamedTuple of outputs (described in `V3dTshiftOutputs`).
    """
    if (
        (slice_timing is not None) +
        (slice_timing_2 is not None)
    ) > 1:
        raise ValueError(
            "Only one of the following arguments can be specified:\n"
            "slice_timing,\n"
            "slice_timing_2"
        )
    if (
        (tpattern is not None) +
        (tpattern_2 is not None)
    ) > 1:
        raise ValueError(
            "Only one of the following arguments can be specified:\n"
            "tpattern,\n"
            "tpattern_2"
        )
    if (
        (tzero is not None) +
        (tslice is not None)
    ) > 1:
        raise ValueError(
            "Only one of the following arguments can be specified:\n"
            "tzero,\n"
            "tslice"
        )
    if (
        (slice_timing is not None) +
        (tpattern is not None)
    ) > 1:
        raise ValueError(
            "Only one of the following arguments can be specified:\n"
            "slice_timing,\n"
            "tpattern"
        )
    execution = runner.start_execution(V_3D_TSHIFT_METADATA)
    cargs = []
    cargs.append("3dTshift")
    cargs.append(execution.input_file(in_file))
    cargs.append("[ARGS]")
    cargs.append("[ENVIRON]")
    if ignore is not None:
        cargs.extend(["-ignore", str(ignore)])
    if interp is not None:
        cargs.extend(["-", interp])
    if num_threads is not None:
        cargs.append(str(num_threads))
    cargs.append("[OUT_FILE]")
    if outputtype is not None:
        cargs.append(outputtype)
    if rlt:
        cargs.append("-rlt")
    if rltplus:
        cargs.append("-rlt+")
    if slice_encoding_direction is not None:
        cargs.append(slice_encoding_direction)
    if slice_timing_2 is not None:
        cargs.extend(["-tpattern @", *map(str, slice_timing_2)])
    if tpattern_2 is not None:
        cargs.extend(["-tpattern", tpattern_2])
    if tr is not None:
        cargs.extend(["-TR", tr])
    if tslice is not None:
        cargs.extend(["-slice", str(tslice)])
    if tzero is not None:
        cargs.extend(["-tzero", str(tzero)])
    ret = V3dTshiftOutputs(
        out_file=execution.output_file(f"{in_file}_tshift", optional=True),
        out_file_=execution.output_file(f"out_file", optional=True),
        timing_file=execution.output_file(f"timing_file", optional=True),
    )
    execution.run(cargs)
    return ret
