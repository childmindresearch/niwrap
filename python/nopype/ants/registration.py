# This file was auto generated by styx
# Do not edit this file directly

import dataclasses
import typing

from ..styxdefs import *


ANTS_REGISTRATION_METADATA = Metadata(
    id="48c29ca0889e34053bbfd7b7d735c2354ba8e6e6",
    name="antsRegistration",
    container_image_type="docker",
    container_image_tag="fcpindi/c-pac:latest",
)


@dataclasses.dataclass
class AntsRegistrationInitialMovingTransform:
    """
    Description missing
    """
    initial_moving_transform_: InputPathType
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(execution.input_file(self.initial_moving_transform_))
        return cargs


@dataclasses.dataclass
class AntsRegistrationInitialMovingTransformUseInverse:
    """
    Description missing
    """
    initial_moving_transform_: InputPathType
    """Description missing"""
    use_inverse: typing.Literal[0, 1] | None = None
    """Use the inverse of the initial moving transform."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "[" +
            execution.input_file(self.initial_moving_transform_) +
            (("," + str(self.use_inverse)) if self.use_inverse is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationInitialMovingTransformInitializationFeature:
    """
    Description missing
    """
    fixed_image: InputPathType
    """Description missing"""
    moving_image: InputPathType
    """Description missing"""
    initialization_feature: typing.Literal[0, 1, 2]
    """Initialization feature. 0: Geometric center of images, 1: Image
    intensities, 2: Origin of images"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "[" +
            execution.input_file(self.fixed_image) +
            "," +
            execution.input_file(self.moving_image) +
            "," +
            str(self.initialization_feature) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformRigid:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "Rigid[" +
            str(self.gradient_step) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformAffine:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "Affine[" +
            str(self.gradient_step) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformCompositeAffine:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "CompositeAffine[" +
            str(self.gradient_step) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformSimilarity:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "Similarity[" +
            str(self.gradient_step) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformTranslation:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "Translation[" +
            str(self.gradient_step) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformBspline:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    mesh_size_at_base_level: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "BSpline[" +
            str(self.gradient_step) +
            "," +
            str(self.mesh_size_at_base_level) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformGaussianDisplacementField:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    update_field_variance_in_voxel_space: float | int
    """Description missing"""
    total_field_variance_in_voxel_space: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "GaussianDisplacementField[" +
            str(self.gradient_step) +
            "," +
            str(self.update_field_variance_in_voxel_space) +
            "," +
            str(self.total_field_variance_in_voxel_space) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformBsplineDisplacementField:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    update_field_mesh_size_at_base_level: float | int
    """Description missing"""
    total_field_mesh_size_at_base_level: float | int | None = None
    """Description missing"""
    spline_order: float | int | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "BSplineDisplacementField[" +
            str(self.gradient_step) +
            "," +
            str(self.update_field_mesh_size_at_base_level) +
            (("," + str(self.total_field_mesh_size_at_base_level)) if self.total_field_mesh_size_at_base_level is not None else "") +
            (str(self.spline_order) if self.spline_order is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformTimeVaryingVelocityField:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    number_of_time_indices: float | int
    """Description missing"""
    update_field_variance_in_voxel_space: float | int
    """Description missing"""
    update_field_time_variance: float | int
    """Description missing"""
    total_field_variance_in_voxel_space: float | int
    """Description missing"""
    total_field_time_variance: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "TimeVaryingVelocityField[" +
            str(self.gradient_step) +
            "," +
            str(self.number_of_time_indices) +
            "," +
            str(self.update_field_variance_in_voxel_space) +
            "," +
            str(self.update_field_time_variance) +
            "," +
            str(self.total_field_variance_in_voxel_space) +
            "," +
            str(self.total_field_time_variance) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformTimeVaryingBsplineVelocityField:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    velocity_field_mesh_size: float | int
    """Description missing"""
    number_of_time_point_samples: float | int | None = None
    """Description missing"""
    spline_order: float | int | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "TimeVaryingBSplineVelocityField[" +
            str(self.gradient_step) +
            "," +
            str(self.velocity_field_mesh_size) +
            (("," + str(self.number_of_time_point_samples)) if self.number_of_time_point_samples is not None else "") +
            (("," + str(self.spline_order)) if self.spline_order is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformSyn:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    update_field_variance_in_voxel_space: float | int
    """Description missing"""
    total_field_variance_in_voxel_space: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "SyN[" +
            str(self.gradient_step) +
            ("," + str(self.update_field_variance_in_voxel_space)) +
            ("," + str(self.total_field_variance_in_voxel_space)) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformBsplineSyn:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    update_field_mesh_size_at_base_level: float | int
    """Description missing"""
    total_field_mesh_size_at_base_level: float | int | None = None
    """Description missing"""
    spline_order: float | int | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "BSplineSyN[" +
            str(self.gradient_step) +
            "," +
            str(self.update_field_mesh_size_at_base_level) +
            (("," + str(self.total_field_mesh_size_at_base_level)) if self.total_field_mesh_size_at_base_level is not None else "") +
            (("," + str(self.spline_order)) if self.spline_order is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformExponential:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    update_field_variance_in_voxel_space: float | int
    """Description missing"""
    velocity_field_variance_in_voxel_space: float | int
    """Description missing"""
    number_of_integration_steps: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "Exponential[" +
            str(self.gradient_step) +
            "," +
            str(self.update_field_variance_in_voxel_space) +
            "," +
            str(self.velocity_field_variance_in_voxel_space) +
            ("," + str(self.number_of_integration_steps)) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationTransformBsplineExponential:
    """
    Description missing
    """
    gradient_step: float | int
    """Description missing"""
    update_field_mesh_size_at_base_level: float | int
    """Description missing"""
    velocity_field_mesh_size_at_base_level: float | int | None = None
    """Description missing"""
    number_of_integration_steps: float | int | None = None
    """Description missing"""
    spline_order: float | int | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "BSplineExponential[" +
            str(self.gradient_step) +
            "," +
            str(self.update_field_mesh_size_at_base_level) +
            (("," + str(self.velocity_field_mesh_size_at_base_level)) if self.velocity_field_mesh_size_at_base_level is not None else "") +
            (("," + str(self.number_of_integration_steps)) if self.number_of_integration_steps is not None else "") +
            (("," + str(self.spline_order)) if self.spline_order is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricAntsNeighbourhoodCrossCorrelation:
    """
    Description missing
    """
    fixed_image: str
    """Description missing"""
    moving_image: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    radius: float | int | None = None
    """Description missing"""
    sampling_strategy: typing.Literal["None", "Regular", "Random"] | None = None
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    use_gradient_filter: typing.Literal["true", "false"] | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "CC[" +
            self.fixed_image +
            "," +
            self.moving_image +
            "," +
            str(self.metric_weight) +
            "," +
            (str(self.radius) if self.radius is not None else "") +
            (("," + self.sampling_strategy) if self.sampling_strategy is not None else "") +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.use_gradient_filter) if self.use_gradient_filter is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricMutualInformation:
    """
    Description missing
    """
    fixed_image: str
    """Description missing"""
    moving_image: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    number_of_bins: float | int | None = None
    """Description missing"""
    sampling_strategy: typing.Literal["None", "Regular", "Random"] | None = None
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    use_gradient_filter: typing.Literal["true", "false"] | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "MI[" +
            self.fixed_image +
            "," +
            self.moving_image +
            "," +
            str(self.metric_weight) +
            "," +
            (str(self.number_of_bins) if self.number_of_bins is not None else "") +
            (("," + self.sampling_strategy) if self.sampling_strategy is not None else "") +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.use_gradient_filter) if self.use_gradient_filter is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricMattes:
    """
    Description missing
    """
    fixed_image: str
    """Description missing"""
    moving_image: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    number_of_bins: float | int | None = None
    """Description missing"""
    sampling_strategy: typing.Literal["None", "Regular", "Random"] | None = None
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    use_gradient_filter: typing.Literal["true", "false"] | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "Mattes[" +
            self.fixed_image +
            "," +
            self.moving_image +
            "," +
            str(self.metric_weight) +
            "," +
            (str(self.number_of_bins) if self.number_of_bins is not None else "") +
            (("," + self.sampling_strategy) if self.sampling_strategy is not None else "") +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.use_gradient_filter) if self.use_gradient_filter is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricMeanSquares:
    """
    Description missing
    """
    fixed_image: str
    """Description missing"""
    moving_image: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    radius: float | int | None = None
    """Description missing"""
    sampling_strategy: typing.Literal["None", "Regular", "Random"] | None = None
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    use_gradient_filter: typing.Literal["true", "false"] | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "MeanSquares[" +
            self.fixed_image +
            "," +
            self.moving_image +
            "," +
            str(self.metric_weight) +
            "," +
            (str(self.radius) if self.radius is not None else "") +
            (("," + self.sampling_strategy) if self.sampling_strategy is not None else "") +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.use_gradient_filter) if self.use_gradient_filter is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricDemons:
    """
    Description missing
    """
    fixed_image: str
    """Description missing"""
    moving_image: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    number_of_bins: float | int | None = None
    """Description missing"""
    sampling_strategy: typing.Literal["None", "Regular", "Random"] | None = None
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    use_gradient_filter: typing.Literal["true", "false"] | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "Demons[" +
            self.fixed_image +
            "," +
            self.moving_image +
            "," +
            str(self.metric_weight) +
            "," +
            (str(self.number_of_bins) if self.number_of_bins is not None else "") +
            (("," + self.sampling_strategy) if self.sampling_strategy is not None else "") +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.use_gradient_filter) if self.use_gradient_filter is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricGlobalCorrelation:
    """
    Description missing
    """
    fixed_image: str
    """Description missing"""
    moving_image: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    radius: float | int | None = None
    """Description missing"""
    sampling_strategy: typing.Literal["None", "Regular", "Random"] | None = None
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    use_gradient_filter: typing.Literal["true", "false"] | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "GC[" +
            self.fixed_image +
            "," +
            self.moving_image +
            "," +
            str(self.metric_weight) +
            "," +
            (str(self.radius) if self.radius is not None else "") +
            (("," + self.sampling_strategy) if self.sampling_strategy is not None else "") +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.use_gradient_filter) if self.use_gradient_filter is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricEuclideanIcp:
    """
    Description missing
    """
    fixed_point_set: str
    """Description missing"""
    moving_point_set: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    boundary_points_only: typing.Literal["0"] | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "ICP[" +
            self.fixed_point_set +
            "," +
            self.moving_point_set +
            "," +
            str(self.metric_weight) +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.boundary_points_only) if self.boundary_points_only is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricPointSetExpectation:
    """
    Description missing
    """
    fixed_point_set: str
    """Description missing"""
    moving_point_set: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    boundary_points_only: typing.Literal["0"] | None = None
    """Description missing"""
    point_set_sigma: float | int | None = None
    """Description missing"""
    k_neighborhood: float | int | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "PSE[[FIXED_IMAGE],[MOVING_IMAGE]," +
            str(self.metric_weight) +
            "," +
            (("," + str(self.point_set_sigma)) if self.point_set_sigma is not None else "") +
            "[SAMPLING_STRATEGY]" +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            "[USE_GRADIENT_FILTER]]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricJensenHavrdaCharvetTsallis:
    """
    Description missing
    """
    fixed_point_set: str
    """Description missing"""
    moving_point_set: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    sampling_percentage: float | int | None = None
    """Description missing"""
    boundary_points_only: typing.Literal["0"] | None = None
    """Description missing"""
    point_set_sigma: float | int | None = None
    """Description missing"""
    k_neighborhood: float | int | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.sampling_percentage is not None and not (0 <= self.sampling_percentage <= 1): 
            raise ValueError(f"'self.sampling_percentage' must be between 0 <= x <= 1 but was {self.sampling_percentage}")
        cargs.append(
            "JHCT[" +
            self.fixed_point_set +
            "," +
            self.moving_point_set +
            "," +
            str(self.metric_weight) +
            (("," + str(self.sampling_percentage)) if self.sampling_percentage is not None else "") +
            (("," + self.boundary_points_only) if self.boundary_points_only is not None else "") +
            (("," + str(self.point_set_sigma)) if self.point_set_sigma is not None else "") +
            (("," + str(self.k_neighborhood)) if self.k_neighborhood is not None else "") +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMetricIgdm:
    """
    Description missing
    """
    fixed_image: str
    """Description missing"""
    moving_image: str
    """Description missing"""
    metric_weight: float | int
    """Description missing"""
    fixed_mask: str
    """Description missing"""
    moving_mask: str
    """Description missing"""
    neighborhood_radius: str | None = None
    """Description missing"""
    intensity_sigma: float | int | None = None
    """Description missing"""
    distance_sigma: float | int | None = None
    """Description missing"""
    k_neighborhood: float | int | None = None
    """Description missing"""
    gradient_sigma: float | int | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append("IGDM[")
        return cargs


@dataclasses.dataclass
class AntsRegistrationConvergence:
    """
    Description missing
    """
    convergence_: str
    """Description missing"""
    convergence_threshold: float | int
    """Description missing"""
    convergence_window_size: int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "[" +
            self.convergence_ +
            ("," + str(self.convergence_threshold)) +
            ("," + str(self.convergence_window_size)) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationStage:
    """
    Stage of the registration process.
    """
    transform: typing.Union[AntsRegistrationTransformRigid, AntsRegistrationTransformAffine, AntsRegistrationTransformCompositeAffine, AntsRegistrationTransformSimilarity, AntsRegistrationTransformTranslation, AntsRegistrationTransformBspline, AntsRegistrationTransformGaussianDisplacementField, AntsRegistrationTransformBsplineDisplacementField, AntsRegistrationTransformTimeVaryingVelocityField, AntsRegistrationTransformTimeVaryingBsplineVelocityField, AntsRegistrationTransformSyn, AntsRegistrationTransformBsplineSyn, AntsRegistrationTransformExponential, AntsRegistrationTransformBsplineExponential]
    """Several transform options are available. The gradientStep or learningRate
    characterizes the gradient descent optimization and is scaled appropriately
    for each transform using the shift scales estimator. Subsequent parameters
    are transform-specific and can be determined from the usage. For the
    B-spline transforms one can also specify the smoothing in terms of spline
    distance (i.e. knot spacing)."""
    metric: typing.Union[AntsRegistrationMetricAntsNeighbourhoodCrossCorrelation, AntsRegistrationMetricMutualInformation, AntsRegistrationMetricMattes, AntsRegistrationMetricMeanSquares, AntsRegistrationMetricDemons, AntsRegistrationMetricGlobalCorrelation, AntsRegistrationMetricEuclideanIcp, AntsRegistrationMetricPointSetExpectation, AntsRegistrationMetricJensenHavrdaCharvetTsallis, AntsRegistrationMetricIgdm]
    """These image metrics are available--- CC: ANTS neighborhood cross
    correlation, MI: Mutual information, Demons: (Thirion), MeanSquares, and GC:
    Global Correlation. The "metricWeight" variable is used to modulate the per
    stage weighting of the metrics. The metrics can also employ a sampling
    strategy defined by a sampling percentage. The sampling strategy defaults to
    'None' (aka a dense sampling of one sample per voxel), otherwise it defines
    a point set over which to optimize the metric. The point set can be on a
    regular lattice or a random lattice of points slightly perturbed to minimize
    aliasing artifacts. samplingPercentage defines the fraction of points to
    select from the domain. useGradientFilter specifies whether a
    smoothingfilter is applied when estimating the metric gradient.In addition,
    three point set metrics are available: Euclidean (ICP), Point-set
    expectation (PSE), and Jensen-Havrda-Charvet-Tsallis (JHCT)."""
    convergence: AntsRegistrationConvergence
    """Convergence is determined from the number of iterations per level and is
    determined by fitting a line to the normalized energy profile of the last N
    iterations (where N is specified by the window size) and determining the
    slope which is then compared with the convergence threshold. """
    smoothing_sigmas: str
    """Specify the sigma of gaussian smoothing at each level. Units are given in
    terms of voxels ('vox') or physical spacing ('mm'). Example usage is
    '4x2x1mm' and '4x2x1vox' where no units implies voxel spacing."""
    shrink_factors: str
    """Specify the shrink factor for the virtual domain (typically the fixed
    image) at each level."""
    use_histogram_matching: typing.Literal[0, 1] | None = None
    """Use histogram matching."""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.extend(["--transform", *self.transform.run(execution)])
        cargs.extend(["--metric", *self.metric.run(execution)])
        cargs.extend(["--convergence", *self.convergence.run(execution)])
        cargs.extend(["--smoothing-sigmas", self.smoothing_sigmas])
        cargs.extend(["--shrink-factors", self.shrink_factors])
        if self.use_histogram_matching is not None:
            cargs.extend(["--use-histogram-matching", str(self.use_histogram_matching)])
        return cargs


@dataclasses.dataclass
class AntsRegistrationWinsorizeImageIntensities:
    """
    Description missing
    """
    lower_quantile: float | int
    """Description missing"""
    upper_quantile: float | int
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        cargs.append(
            "[" +
            str(self.lower_quantile) +
            str(self.upper_quantile) +
            "]"
        )
        return cargs


@dataclasses.dataclass
class AntsRegistrationMasks:
    """
    Description missing
    """
    fixed_mask: str | None = None
    """Description missing"""
    moving_mask: str | None = None
    """Description missing"""
    
    def run(
        self,
        execution: Execution,
    ) -> list[str]:
        """
        Build command line arguments. This method is called by the main command.
        
        Args:
            self: The sub-command object.
            execution: The execution object.
        Returns:
            
        """
        cargs = []
        if self.fixed_mask is not None or self.moving_mask is not None:
            cargs.append(
                "[" +
                (self.fixed_mask if self.fixed_mask is not None else "") +
                (self.moving_mask if self.moving_mask is not None else "") +
                "]"
            )
        return cargs


class AntsRegistrationOutputs(typing.NamedTuple):
    """
    Output object returned when calling `ants_registration(...)`.
    """
    output_transform: OutputPathType
    """The output transform file."""


def ants_registration(
    runner: Runner,
    stages: list[AntsRegistrationStage],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    output: str | None = None,
    save_state: str | None = None,
    restore_state: str | None = None,
    write_composite_transform: typing.Literal[0, 1] | None = None,
    print_similarity_measure_interval: int | None = None,
    write_interval_volumes: int | None = None,
    collapse_output_transforms: typing.Literal[1, 0] | None = None,
    initialize_transforms_per_stage: typing.Literal[1, 0] | None = None,
    interpolation: typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None = None,
    restrict_deformation: list[typing.Literal[0, 1]] = None,
    initial_fixed_transform: str | None = None,
    initial_moving_transform: typing.Union[AntsRegistrationInitialMovingTransform, AntsRegistrationInitialMovingTransformUseInverse, AntsRegistrationInitialMovingTransformInitializationFeature] | None = None,
    winsorize_image_intensities: AntsRegistrationWinsorizeImageIntensities | None = None,
    masks: AntsRegistrationMasks | None = None,
    minc: typing.Literal[0, 1] | None = None,
    random_seed: int | None = None,
    verbose: typing.Literal[0, 1] | None = None,
    float_: typing.Literal[0, 1] | None = None,
) -> AntsRegistrationOutputs:
    """
    This program is a user-level registration application meant to utilize classes
    in ITK v4.0 and later. The user can specify any number of "stages" where a stage
    consists of a transform; an image metric; and iterations, shrink factors, and
    smoothing sigmas for each level. Note that explicitly setting the
    dimensionality, metric, transform, output, convergence, shrink-factors, and
    smoothing-sigmas parameters is mandatory.
    
    Args:
        runner: Command runner
        stages: Stages of the registration process.
        dimensionality: This option forces the image to be treated as a
            specified-dimensional image. If not specified, we try to infer the
            dimensionality from the input image.
        output: Specify the output transform prefix (output format is .nii.gz ).
            Optionally, one can choose to warp the moving image to the fixed space
            and, if the inverse transform exists, one can also output the warped
            fixed image. Note that only the images specified in the first metric
            call are warped. Use antsApplyTransforms to warp other images using the
            resultant transform(s). When a composite transform is not specified,
            linear transforms are specified with a '.mat' suffix and displacement
            fields with a 'Warp.nii.gz' suffix (and 'InverseWarp.nii.gz', when
            applicable. In addition, for velocity-based transforms, the full
            velocity field is written to file ('VelocityField.nii.gz') as long as
            the collapse transforms flag is turned off ('-z 0').
        save_state: Specify the output file for the current state of the
            registration. The state file is written to an hdf5 composite file. It is
            specially usefull if we want to save the current state of a SyN
            registration to the disk, so we can load and restore that later to
            continue the next registration process directly started from the last
            saved state. The output file of this flag is the same as the
            write-composite-transform, unless the last transform is a SyN transform.
            In that case, the inverse displacement field of the SyN transform is
            also added to the output composite transform. Again notice that this
            file cannot be treated as a transform, and restore-state option must be
            used to load the written file by this flag.
        restore_state: Specify the initial state of the registration which get
            immediately used to directly initialize the registration process. The
            flag is mutually exclusive with other intialization flags.If this flag
            is used, none of the initial-moving-transform and
            initial-fixed-transform cannot be used.
        write_composite_transform: Boolean specifying whether or not the
            composite transform (and its inverse, if it exists) should be written to
            an hdf5 composite file. This is false by default so that only the
            transform for each stage is written to file.
        print_similarity_measure_interval: Prints out the CC similarity metric
            measure between the full-size input fixed and the transformed moving
            images at each iteration a value of 0 (the default) indicates that the
            full scale computation should not take placeany value greater than 0
            represents the interval of full scale metric computation.
        write_interval_volumes: Writes out the output volume at each iteration.
            It helps to present the registration process as a short movie a value of
            0 (the default) indicates that this option should not take placeany
            value greater than 0 represents the interval between the iterations
            which outputs are written to the disk.
        collapse_output_transforms: Collapse output transforms. Specifically,
            enabling this option combines all adjacent transforms where possible.
            All adjacent linear transforms are written to disk in the form of an itk
            affine transform (called xxxGenericAffine.mat).
            Similarly, all adjacent displacement
            field transforms are combined when
            written to disk (e.g. xxxWarp.nii.gz and
            xxxInverseWarp.nii.gz (if available)).
            Also, an output composite transform
            including the collapsed transforms is
            written to the disk (called
            outputCollapsed(Inverse)Composite).
        initialize_transforms_per_stage: Initialize linear transforms from the
            previous stage. By enabling this option, the current linear stage
            transform is directly intialized from the previous stage's linear
            transform; this allows multiple linear stages to be run where each stage
            directly updates the estimated linear transform from the previous stage.
            (e.g. Translation -> Rigid -> Affine).
        interpolation: Several interpolation options are available in ITK. These
            have all been made available. Currently the interpolator choice is only
            used to warp (and possibly inverse warp) the final output image(s).
        restrict_deformation: This option allows the user to restrict the
            optimization of the displacement field, translation, rigid or affine
            transform on a per-component basis. For example, if one wants to limit
            the deformation or rotation of 3-D volume to the first two dimensions,
            this is possible by specifying a weight vector of '1x1x0' for a
            deformation field or '1x1x0x1x1x0' for a rigid transformation.
            Low-dimensional restriction only works if there are no preceding
            transformations.All stages up to and including the desired stage must
            have this option specified,even if they should not be restricted (in
            which case specify 1x1x1...)
        initial_fixed_transform: Specify the initial fixed transform(s) which
            get immediately incorporated into the composite transform. The order of
            the transforms is stack-esque in that the last transform specified on
            the command line is the first to be applied. In addition to
            initialization with ITK transforms, the user can perform an initial
            translation alignment by specifying the fixed and moving images and
            selecting an initialization feature. These features include using the
            geometric center of the images (=0), the image intensities (=1), or the
            origin of the images (=2).
        initial_moving_transform: Specify the initial moving transform(s) which
            get immediately incorporated into the composite transform. The order of
            the transforms is stack-esque in that the last transform specified on
            the command line is the first to be applied. In addition to
            initialization with ITK transforms, the user can perform an initial
            translation alignment by specifying the fixed and moving images and
            selecting an initialization feature. These features include using the
            geometric center of the images (=0), the image intensities (=1), or the
            origin of the images (=2).
        winsorize_image_intensities: Winsorize data based on specified
            quantiles.
        masks: Image masks to limit voxels considered by the metric. Two options
            are allowed for mask specification: 1) Either the user specifies a
            single mask to be used for all stages or 2) the user specifies a mask
            for each stage. With the latter one can select to which stages masks are
            applied by supplying valid file names. If the file does not exist, a
            mask will not be used for that stage. Note that we handle the fixed and
            moving masks separately to enforce this constraint.
        minc: Use MINC file formats for transformations.
        random_seed: Random seed.
        verbose: Verbose output.
        float_: Use 'float' instead of 'double' for computations.
    Returns:
        NamedTuple of outputs (described in `AntsRegistrationOutputs`).
    """
    if write_interval_volumes is not None and not (0 <= write_interval_volumes): 
        raise ValueError(f"'write_interval_volumes' must be greater than 0 <= x but was {write_interval_volumes}")
    if restrict_deformation is not None and not (3 <= len(restrict_deformation) <= 6): 
        raise ValueError(f"Length of 'restrict_deformation' must be between 3 and 6 but was {len(restrict_deformation)}")
    if random_seed is not None and not (1 <= random_seed): 
        raise ValueError(f"'random_seed' must be greater than 1 <= x but was {random_seed}")
    execution = runner.start_execution(ANTS_REGISTRATION_METADATA)
    cargs = []
    cargs.append("antsRegistration")
    if dimensionality is not None:
        cargs.extend(["--dimensionality", str(dimensionality)])
    if output is not None:
        cargs.extend(["-o", output])
    if save_state is not None:
        cargs.extend(["-j", save_state])
    if restore_state is not None:
        cargs.extend(["-k", restore_state])
    if write_composite_transform is not None:
        cargs.extend(["-a", str(write_composite_transform)])
    if print_similarity_measure_interval is not None:
        cargs.extend(["-p", str(print_similarity_measure_interval)])
    if write_interval_volumes is not None:
        cargs.extend(["--write-interval-volumes", str(write_interval_volumes)])
    if collapse_output_transforms is not None:
        cargs.extend(["--collapse-output-transforms", str(collapse_output_transforms)])
    if initialize_transforms_per_stage is not None:
        cargs.extend(["-i", str(initialize_transforms_per_stage)])
    if interpolation is not None:
        cargs.extend(["--interpolation", interpolation])
    if restrict_deformation is not None:
        cargs.extend(["-g", "x".join(map(str, restrict_deformation))])
    if initial_fixed_transform is not None:
        cargs.extend(["-q", initial_fixed_transform])
    if initial_moving_transform is not None:
        cargs.extend(["--initial-moving-transform", *initial_moving_transform.run(execution)])
    cargs.extend([a for c in [s.run(execution) for s in stages] for a in c])
    if winsorize_image_intensities is not None:
        cargs.extend(["--winsorize-image-intensities", *winsorize_image_intensities.run(execution)])
    if masks is not None:
        cargs.extend(["--masks", *masks.run(execution)])
    if minc is not None:
        cargs.extend(["--minc", str(minc)])
    if random_seed is not None:
        cargs.extend(["--random-seed", str(random_seed)])
    if verbose is not None:
        cargs.extend(["-v", str(verbose)])
    ret = AntsRegistrationOutputs(
        output_transform=execution.output_file(f"{output}"),
    )
    execution.run(cargs)
    return ret
