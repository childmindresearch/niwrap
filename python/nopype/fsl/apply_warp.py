# This file was auto generated by styx-boutiques-codegen
# Do not edit this file directly
# Timestamp: 2024-05-16T18:58:56.032598

import typing

from ..styxdefs import *


APPLY_WARP_METADATA = Metadata(
    id="33fae68fc47c34d7470dad22d5684709a0bf4166",
    name="ApplyWarp",
    container_image_type="docker",
    container_image_tag="fcpindi/c-pac:latest",
)


class ApplyWarpOutputs(typing.NamedTuple):
    """
    Output object returned when calling `apply_warp(...)`.
    """
    out_file_outfile: OutputPathType
    """Warped output file."""


def apply_warp(
    runner: Runner,
    in_file: InputPathType,
    ref_file: InputPathType,
    abswarp: bool = False,
    datatype: typing.Literal["char", "short", "int", "float", "double"] | None = None,
    field_file: InputPathType | None = None,
    interp: typing.Literal["nn", "trilinear", "sinc", "spline"] | None = None,
    mask_file: InputPathType | None = None,
    out_file: InputPathType | None = None,
    output_type: typing.Literal["NIFTI", "NIFTI_PAIR", "NIFTI_GZ", "NIFTI_PAIR_GZ"] | None = None,
    postmat: InputPathType | None = None,
    premat: InputPathType | None = None,
    relwarp: bool = False,
    superlevel: typing.Literal["a"] | None = None,
    superlevel_2: int | None = None,
    supersample: bool = False,
) -> ApplyWarpOutputs:
    """
    ApplyWarp, as implemented in Nipype (module: nipype.interfaces.fsl, interface:
    ApplyWarp).
    FSL's applywarp wrapper to apply the results of a FNIRT registration
    
    Args:
        runner: Command runner
        in_file: Image to be warped.
        ref_file: Reference image.
        abswarp: Treat warp field as absolute: x' = w(x).
        datatype: 'char' or 'short' or 'int' or 'float' or 'double'. Force
            output data type [char short int float double].
        field_file: File containing warp field.
        interp: 'nn' or 'trilinear' or 'sinc' or 'spline'. Interpolation method.
        mask_file: Filename for mask image (in reference space).
        out_file: Output filename.
        output_type: 'nifti' or 'nifti_pair' or 'nifti_gz' or 'nifti_pair_gz'.
            Fsl output type.
        postmat: Filename for post-transform (affine matrix).
        premat: Filename for pre-transform (affine matrix).
        relwarp: Treat warp field as relative: x' = x + w(x).
        superlevel: 'a' or an integer. Level of intermediary supersampling, a
            for 'automatic' or integer level. default = 2.
        superlevel_2: 'a' or an integer. Level of intermediary supersampling, a
            for 'automatic' or integer level. default = 2.
        supersample: Intermediary supersampling of output, default is off.
    Returns:
        NamedTuple of outputs (described in `ApplyWarpOutputs`).
    """
    if (
        (superlevel is not None) +
        (superlevel_2 is not None)
    ) > 1:
        raise ValueError(
            "Only one of the following arguments can be specified:\n"
            "superlevel,\n"
            "superlevel_2"
        )
    if (
        relwarp +
        abswarp
    ) > 1:
        raise ValueError(
            "Only one of the following arguments can be specified:\n"
            "relwarp,\n"
            "abswarp"
        )
    execution = runner.start_execution(APPLY_WARP_METADATA)
    cargs = []
    cargs.append("ApplyWarp")
    if interp is not None:
        cargs.append(("--interp=" + interp))
    cargs.append(("--in=" + execution.input_file(in_file)))
    cargs.append(("--ref=" + execution.input_file(ref_file)))
    if out_file is not None:
        cargs.append(("--out=" + execution.input_file(out_file)))
    if relwarp:
        cargs.append("--rel")
    if abswarp:
        cargs.append("--abs")
    cargs.append("[ARGS]")
    if datatype is not None:
        cargs.append(("--datatype=" + datatype))
    cargs.append("[ENVIRON]")
    if field_file is not None:
        cargs.append(("--warp=" + execution.input_file(field_file)))
    if mask_file is not None:
        cargs.append(("--mask=" + execution.input_file(mask_file)))
    if output_type is not None:
        cargs.append(output_type)
    if postmat is not None:
        cargs.append(("--postmat=" + execution.input_file(postmat)))
    if premat is not None:
        cargs.append(("--premat=" + execution.input_file(premat)))
    if superlevel_2 is not None:
        cargs.append(("--superlevel=" + str(superlevel_2)))
    if supersample:
        cargs.append("--super")
    ret = ApplyWarpOutputs(
        out_file_outfile=execution.output_file(f"{out_file}", optional=True),
    )
    execution.run(cargs)
    return ret
